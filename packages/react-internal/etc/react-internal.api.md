## API Report File for "@fluentui/react-internal"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { DateRangeType } from '@fluentui/date-time-utilities/lib/dateValues/dateValues';
import { DayOfWeek } from '@fluentui/date-time-utilities/lib/dateValues/dateValues';
import { EventGroup } from '@uifabric/utilities';
import { FirstWeekOfYear } from '@fluentui/date-time-utilities/lib/dateValues/dateValues';
import { IBaseProps } from '@uifabric/utilities';
import { IComponent } from '@uifabric/foundation';
import { IComponentAs } from '@uifabric/utilities';
import { IComponentStyles } from '@uifabric/foundation';
import { ICSSPixelUnitRule } from '@uifabric/merge-styles/lib/IRawStyleBase';
import { ICSSRule } from '@uifabric/merge-styles/lib/IRawStyleBase';
import { IFocusZone } from '@fluentui/react-focus';
import { IFocusZoneProps } from '@fluentui/react-focus';
import { IFontStyles } from '@uifabric/styling';
import { IHTMLSlot } from '@uifabric/foundation';
import { IObjectWithKey } from '@uifabric/utilities';
import { IPoint } from '@uifabric/utilities';
import { IRawStyle } from '@uifabric/styling';
import { IRectangle } from '@uifabric/utilities';
import { IRefObject } from '@uifabric/utilities';
import { IRenderComponent } from '@uifabric/utilities';
import { IRenderFunction } from '@uifabric/utilities';
import { ISelection } from '@uifabric/utilities';
import { ISelectionOptions } from '@uifabric/utilities';
import { ISlotProp } from '@uifabric/foundation';
import { ISlottableProps } from '@uifabric/foundation';
import { IStyle } from '@uifabric/styling';
import { IStyleableComponentProps } from '@uifabric/foundation';
import { IStyleFunction } from '@uifabric/utilities';
import { IStyleFunctionOrObject } from '@uifabric/utilities';
import { ITheme } from '@uifabric/styling';
import { KeyCodes } from '@uifabric/utilities';
import { Point } from '@uifabric/utilities';
import * as React from 'react';
import { ReactNode } from 'react';
import { Rectangle } from '@uifabric/utilities';
import { Selection } from '@uifabric/utilities';
import { SELECTION_CHANGE } from '@uifabric/utilities';
import { SelectionDirection } from '@uifabric/utilities';
import { SelectionMode } from '@uifabric/utilities';
import { Target } from '@uifabric/react-hooks';

// @public (undocumented)
export class ActionButton extends React.Component<IButtonProps, {}> {
    // (undocumented)
    render(): JSX.Element;
}

// @public (undocumented)
export class ActivityItem extends React.Component<IActivityItemProps, {}> {
    constructor(props: IActivityItemProps);
    // (undocumented)
    render(): JSX.Element;
}

// @public
export type Alignment = 'start' | 'end' | 'center' | 'space-between' | 'space-around' | 'space-evenly' | 'baseline' | 'stretch';

// @public (undocumented)
export const Announced: React.FunctionComponent<IAnnouncedProps>;

// @public (undocumented)
export class AnnouncedBase extends React.Component<IAnnouncedProps> {
    // (undocumented)
    static defaultProps: Partial<IAnnouncedProps>;
    // (undocumented)
    render(): JSX.Element;
}

// @public (undocumented)
export class Autofill extends React.Component<IAutofillProps, IAutofillState> implements IAutofill {
    constructor(props: IAutofillProps);
    // (undocumented)
    clear(): void;
    // (undocumented)
    componentDidUpdate(): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    readonly cursorLocation: number | null;
    // (undocumented)
    static defaultProps: {
        enableAutofillOnKeyPress: number[];
    };
    // (undocumented)
    focus(): void;
    // (undocumented)
    readonly inputElement: HTMLInputElement | null;
    // (undocumented)
    readonly isValueSelected: boolean;
    // (undocumented)
    render(): JSX.Element;
    // (undocumented)
    readonly selectionEnd: number | null;
    // (undocumented)
    readonly selectionStart: number | null;
    // (undocumented)
    UNSAFE_componentWillReceiveProps(nextProps: IAutofillProps): void;
    // (undocumented)
    readonly value: string;
    }

// @public @deprecated (undocumented)
export class BaseAutoFill extends Autofill {
}

// @public (undocumented)
export class BaseButton extends React.Component<IBaseButtonProps, IBaseButtonState> implements IButton {
    constructor(props: IBaseButtonProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentDidUpdate(prevProps: IBaseButtonProps, prevState: IBaseButtonState): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    static defaultProps: Partial<IBaseButtonProps>;
    // (undocumented)
    dismissMenu(): void;
    // (undocumented)
    focus(): void;
    // (undocumented)
    openMenu(shouldFocusOnContainer?: boolean, shouldFocusOnMount?: boolean): void;
    // (undocumented)
    render(): JSX.Element;
    }

// @public (undocumented)
export class BaseExtendedPeoplePicker extends BaseExtendedPicker<IPersonaProps, IExtendedPeoplePickerProps> {
}

// @public (undocumented)
export class BaseExtendedPicker<T, P extends IBaseExtendedPickerProps<T>> extends React.Component<P, IBaseExtendedPickerState<T>> implements IBaseExtendedPicker<T> {
    constructor(basePickerProps: P);
    // (undocumented)
    protected canAddItems(): boolean;
    // (undocumented)
    clearInput(): void;
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    floatingPicker: React.RefObject<BaseFloatingPicker<T, IBaseFloatingPickerProps<T>>>;
    // (undocumented)
    protected floatingPickerProps: IBaseFloatingPickerProps<T>;
    // (undocumented)
    focus(): void;
    // (undocumented)
    readonly highlightedItems: T[];
    // (undocumented)
    protected input: React.RefObject<Autofill>;
    // (undocumented)
    readonly inputElement: HTMLInputElement | null;
    // (undocumented)
    readonly items: any;
    // (undocumented)
    protected onBackspace: (ev: React.KeyboardEvent<HTMLElement>) => void;
    // (undocumented)
    protected onCopy: (ev: React.ClipboardEvent<HTMLElement>) => void;
    // (undocumented)
    protected onInputChange: (value: string, composing?: boolean | undefined) => void;
    // (undocumented)
    protected onInputClick: (ev: React.MouseEvent<HTMLInputElement | Autofill, MouseEvent>) => void;
    // (undocumented)
    protected onInputFocus: (ev: React.FocusEvent<HTMLInputElement | Autofill>) => void;
    // (undocumented)
    protected onPaste: (ev: React.ClipboardEvent<HTMLInputElement | Autofill>) => void;
    // (undocumented)
    protected _onSelectedItemsChanged: () => void;
    // (undocumented)
    protected onSelectionChange: () => void;
    // (undocumented)
    protected _onSuggestionSelected: (item: T) => void;
    // (undocumented)
    render(): JSX.Element;
    // (undocumented)
    protected renderFloatingPicker(): JSX.Element;
    // (undocumented)
    protected renderSelectedItemsList(): JSX.Element;
    // (undocumented)
    protected root: React.RefObject<HTMLDivElement>;
    // (undocumented)
    selectedItemsList: React.RefObject<BaseSelectedItemsList<T, IBaseSelectedItemsListProps<T>>>;
    // (undocumented)
    protected selectedItemsListProps: IBaseSelectedItemsListProps<T>;
    // (undocumented)
    protected selection: Selection;
    // (undocumented)
    UNSAFE_componentWillReceiveProps(newProps: P): void;
}

// @public (undocumented)
export class BaseFloatingPeoplePicker extends BaseFloatingPicker<IPersonaProps, IPeopleFloatingPickerProps> {
}

// @public (undocumented)
export class BaseFloatingPicker<T, P extends IBaseFloatingPickerProps<T>> extends React.Component<P, IBaseFloatingPickerState> implements IBaseFloatingPicker {
    constructor(basePickerProps: P);
    // (undocumented)
    completeSuggestion: () => void;
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentDidUpdate(): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    protected currentPromise: PromiseLike<T[]>;
    // (undocumented)
    readonly currentSelectedSuggestionIndex: number;
    // (undocumented)
    forceResolveSuggestion(): void;
    // (undocumented)
    hidePicker: () => void;
    // (undocumented)
    readonly inputText: string;
    // (undocumented)
    protected isComponentMounted: boolean;
    // (undocumented)
    readonly isSuggestionsShown: boolean;
    // (undocumented)
    protected onChange(item: T): void;
    // (undocumented)
    protected onKeyDown: (ev: MouseEvent) => void;
    // (undocumented)
    onQueryStringChanged: (queryString: string) => void;
    // (undocumented)
    protected onSelectionChange(): void;
    // (undocumented)
    protected onSuggestionClick: (ev: React.MouseEvent<HTMLElement, MouseEvent>, item: T, index: number) => void;
    // (undocumented)
    protected onSuggestionRemove: (ev: React.MouseEvent<HTMLElement, MouseEvent>, item: T, index: number) => void;
    // (undocumented)
    render(): JSX.Element;
    // (undocumented)
    protected renderSuggestions(): JSX.Element | null;
    // (undocumented)
    protected root: React.RefObject<HTMLDivElement>;
    // (undocumented)
    protected selection: Selection;
    // (undocumented)
    showPicker: (updateValue?: boolean) => void;
    // (undocumented)
    readonly suggestions: any[];
    // (undocumented)
    protected suggestionsControl: React.RefObject<SuggestionsControl<T>>;
    // (undocumented)
    protected SuggestionsControlOfProperType: new (props: ISuggestionsControlProps<T>) => SuggestionsControl<T>;
    // (undocumented)
    protected suggestionStore: SuggestionsStore<T>;
    // (undocumented)
    UNSAFE_componentWillReceiveProps(newProps: IBaseFloatingPickerProps<T>): void;
    // (undocumented)
    updateSuggestions(suggestions: T[], forceUpdate?: boolean): void;
    // (undocumented)
    protected updateSuggestionsList(suggestions: T[] | PromiseLike<T[]>): void;
    // (undocumented)
    protected updateSuggestionWithZeroState(): void;
    // (undocumented)
    protected updateValue(updatedValue: string): void;
}

// @public (undocumented)
export class BasePeoplePicker extends BasePicker<IPersonaProps, IPeoplePickerProps> {
}

// @public (undocumented)
export class BasePeopleSelectedItemsList extends BaseSelectedItemsList<IExtendedPersonaProps, ISelectedPeopleProps> {
}

// @public (undocumented)
export class BasePicker<T, P extends IBasePickerProps<T>> extends React.Component<P, IBasePickerState> implements IBasePicker<T> {
    constructor(basePickerProps: P);
    // (undocumented)
    protected addItem: (item: T) => void;
    // (undocumented)
    protected addItemByIndex: (index: number) => void;
    // (undocumented)
    protected _ariaMap: IPickerAriaIds;
    // (undocumented)
    protected canAddItems(): boolean;
    // (undocumented)
    protected completeSelection: (item: T) => void;
    // (undocumented)
    completeSuggestion(forceComplete?: boolean): void;
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentDidUpdate(oldProps: P, oldState: IBasePickerState): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    protected currentPromise: PromiseLike<any> | undefined;
    // (undocumented)
    dismissSuggestions: (ev?: any) => void;
    // (undocumented)
    focus(): void;
    // (undocumented)
    focusInput(): void;
    // (undocumented)
    protected focusZone: React.RefObject<IFocusZone>;
    // (undocumented)
    protected getActiveDescendant(): string | undefined;
    // (undocumented)
    static getDerivedStateFromProps(newProps: IBasePickerProps<any>): {
        items: any[];
    } | null;
    // (undocumented)
    protected getSuggestionsAlert(suggestionAlertClassName?: string): JSX.Element | undefined;
    // (undocumented)
    protected input: React.RefObject<IAutofill>;
    // (undocumented)
    readonly items: T[];
    // (undocumented)
    protected onBackspace(ev: React.KeyboardEvent<HTMLElement>): void;
    // (undocumented)
    protected onBlur: (ev: React.FocusEvent<HTMLElement | Autofill>) => void;
    // (undocumented)
    protected onChange(items?: T[]): void;
    protected onClick: (ev: React.MouseEvent<HTMLInputElement, MouseEvent>) => void;
    protected onEmptyInputFocus(): void;
    // (undocumented)
    protected onGetMoreResults: () => void;
    // (undocumented)
    protected onInputBlur: (ev: React.FocusEvent<HTMLInputElement | Autofill>) => void;
    // (undocumented)
    protected onInputChange: (value: string) => void;
    // (undocumented)
    protected onInputFocus: (ev: React.FocusEvent<HTMLInputElement | Autofill>) => void;
    // (undocumented)
    protected onItemChange: (changedItem: T, index: number) => void;
    // (undocumented)
    protected onKeyDown: (ev: React.KeyboardEvent<HTMLElement>) => void;
    // (undocumented)
    protected onSelectionChange(): void;
    // (undocumented)
    protected onSuggestionClick: (ev: React.MouseEvent<HTMLElement, MouseEvent>, item: any, index: number) => void;
    // (undocumented)
    protected onSuggestionRemove: (ev: React.MouseEvent<HTMLElement, MouseEvent>, item: T, index: number) => void;
    // (undocumented)
    protected onSuggestionSelect(): void;
    // (undocumented)
    refocusSuggestions: (keyCode: number) => void;
    // (undocumented)
    protected removeItem: (item: IPickerItemProps<T>, focusNextItem?: boolean | undefined) => void;
    // (undocumented)
    protected removeItems: (itemsToRemove: any[]) => void;
    // (undocumented)
    render(): JSX.Element;
    // (undocumented)
    protected renderItems(): JSX.Element[];
    // (undocumented)
    protected renderSuggestions(): JSX.Element | null;
    // (undocumented)
    protected resetFocus(index?: number): void;
    // (undocumented)
    protected resolveNewValue(updatedValue: string, suggestions: T[]): void;
    // (undocumented)
    protected root: React.RefObject<HTMLDivElement>;
    // (undocumented)
    protected selection: Selection;
    // (undocumented)
    protected _shouldFocusZoneEnterInnerZone: (ev: React.KeyboardEvent<HTMLElement>) => boolean;
    // (undocumented)
    protected suggestionElement: React.RefObject<ISuggestions<T>>;
    // @deprecated (undocumented)
    protected SuggestionOfProperType: new (props: ISuggestionsProps<T>) => Suggestions<T>;
    // (undocumented)
    protected suggestionStore: SuggestionsController<T>;
    // (undocumented)
    protected updateSuggestions(suggestions: any[]): void;
    // (undocumented)
    protected updateSuggestionsList(suggestions: T[] | PromiseLike<T[]>, updatedValue?: string): void;
    // (undocumented)
    protected updateValue(updatedValue: string): void;
    }

// @public (undocumented)
export class BasePickerListBelow<T, P extends IBasePickerProps<T>> extends BasePicker<T, P> {
    // (undocumented)
    protected onBackspace(ev: React.KeyboardEvent<HTMLElement>): void;
    // (undocumented)
    render(): JSX.Element;
}

// @public (undocumented)
export class BaseSelectedItemsList<T, P extends IBaseSelectedItemsListProps<T>> extends React.Component<P, IBaseSelectedItemsListState<T>> implements IBaseSelectedItemsList<T> {
    constructor(basePickerProps: P);
    // (undocumented)
    addItems: (items: T[]) => void;
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    protected copyItems(items: T[]): void;
    // (undocumented)
    hasSelectedItems(): boolean;
    // (undocumented)
    highlightedItems(): T[];
    // (undocumented)
    readonly items: T[];
    // (undocumented)
    protected onChange(items?: T[]): void;
    // (undocumented)
    onCopy: (ev: React.ClipboardEvent<HTMLElement>) => void;
    // (undocumented)
    protected onItemChange: (changedItem: T, index: number) => void;
    // (undocumented)
    protected onSelectionChanged: () => void;
    // (undocumented)
    removeItem: (item: T) => void;
    // (undocumented)
    removeItemAt: (index: number) => void;
    // (undocumented)
    removeItems: (itemsToRemove: any[]) => void;
    // (undocumented)
    removeSelectedItems(): void;
    // (undocumented)
    render(): any;
    // (undocumented)
    protected renderItems: () => JSX.Element[];
    // (undocumented)
    replaceItem: (itemToReplace: T, itemsToReplaceWith: T[]) => void;
    // (undocumented)
    protected root: HTMLElement;
    // (undocumented)
    protected selection: Selection;
    // (undocumented)
    UNSAFE_componentWillReceiveProps(newProps: P): void;
    // (undocumented)
    UNSAFE_componentWillUpdate(newProps: P, newState: IBaseSelectedItemsListState): void;
    // (undocumented)
    unselectAll(): void;
    updateItems(items: T[], focusIndex?: number): void;
}

// @public (undocumented)
export enum BaseSlots {
    // (undocumented)
    backgroundColor = 1,
    // (undocumented)
    foregroundColor = 2,
    // (undocumented)
    primaryColor = 0
}

// @public
export function buildKeytipConfigMap(config: IKeytipConfig): IKeytipConfigMap;

// @public @deprecated
export class Button extends React.Component<IButtonProps, {}> {
    constructor(props: IButtonProps);
    // (undocumented)
    render(): JSX.Element;
}

// @public (undocumented)
export const ButtonGrid: React.FunctionComponent<IButtonGridProps>;

// @public (undocumented)
export const ButtonGridCell: <T, P extends IButtonGridCellProps<T>>(props: IButtonGridCellProps<T>) => JSX.Element;

// @public (undocumented)
export enum ButtonType {
    // (undocumented)
    command = 4,
    // (undocumented)
    compound = 3,
    // (undocumented)
    default = 6,
    // (undocumented)
    hero = 2,
    // (undocumented)
    icon = 5,
    // (undocumented)
    normal = 0,
    // (undocumented)
    primary = 1
}

// @public (undocumented)
export class Calendar extends React.Component<ICalendarProps, ICalendarState> implements ICalendar {
    constructor(props: ICalendarProps);
    // (undocumented)
    componentDidUpdate(): void;
    // (undocumented)
    static defaultProps: ICalendarProps;
    // (undocumented)
    focus(): void;
    // (undocumented)
    render(): JSX.Element;
    // (undocumented)
    UNSAFE_componentWillReceiveProps(nextProps: ICalendarProps): void;
}

// Warning: (ae-forgotten-export) The symbol "ICalloutState" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export class Callout extends React.Component<ICalloutProps, ICalloutState> {
    // (undocumented)
    render(): JSX.Element;
}

// @public
export function canAnyMenuItemsCheck(items: IContextualMenuItem[]): boolean;

// @public (undocumented)
export const Check: React.FunctionComponent<ICheckProps>;

// @public (undocumented)
export const CheckBase: React.FunctionComponent<ICheckProps>;

// @public (undocumented)
export const ChoiceGroup: React.FunctionComponent<IChoiceGroupProps>;

// @public (undocumented)
export const ChoiceGroupBase: React.FunctionComponent<IChoiceGroupProps>;

// @public (undocumented)
export const ChoiceGroupOption: React.FunctionComponent<IChoiceGroupOptionProps>;

// @public
export function clamp(value: number, max: number, min?: number): number;

// @public (undocumented)
export const Coachmark: React.FunctionComponent<ICoachmarkProps>;

// @public (undocumented)
export const COACHMARK_ATTRIBUTE_NAME = "data-coachmarkid";

// @public (undocumented)
export const CoachmarkBase: React.FunctionComponent<ICoachmarkProps>;

// @public (undocumented)
export const ColorPicker: React.FunctionComponent<IColorPickerProps>;

// @public (undocumented)
export class ColorPickerBase extends React.Component<IColorPickerProps, IColorPickerState> implements IColorPicker {
    constructor(props: IColorPickerProps);
    // (undocumented)
    readonly color: IColor;
    // (undocumented)
    componentDidUpdate(prevProps: Readonly<IColorPickerProps>, prevState: Readonly<IColorPickerState>): void;
    // (undocumented)
    static defaultProps: Partial<IColorPickerProps>;
    // (undocumented)
    render(): JSX.Element;
    }

// @public (undocumented)
export const ColorPickerGridCell: React.FunctionComponent<IColorPickerGridCellProps>;

// @public (undocumented)
export const ColorPickerGridCellBase: React.FunctionComponent<IColorPickerGridCellProps>;

// @public (undocumented)
export const CommandBar: React.FunctionComponent<ICommandBarProps>;

// @public (undocumented)
export class CommandBarBase extends React.Component<ICommandBarProps, {}> implements ICommandBar {
    constructor(props: ICommandBarProps);
    // (undocumented)
    static defaultProps: ICommandBarProps;
    // (undocumented)
    focus(): void;
    // (undocumented)
    remeasure(): void;
    // (undocumented)
    render(): JSX.Element;
    }

// @public (undocumented)
export class CommandBarButton extends React.Component<IButtonProps, {}> {
    // (undocumented)
    render(): JSX.Element;
}

// @public (undocumented)
export const CommandButton: typeof ActionButton;

// @public (undocumented)
export const CompactPeoplePicker: React.FunctionComponent<IPeoplePickerProps>;

// @public
export class CompactPeoplePickerBase extends BasePeoplePicker {
    static defaultProps: {
        onRenderItem: (props: IPeoplePickerItemSelectedProps) => JSX.Element;
        onRenderSuggestionsItem: (personaProps: IPersonaProps, suggestionsProps?: IBasePickerSuggestionsProps<any> | undefined) => JSX.Element;
        createGenericItem: typeof createGenericItem;
    };
}

// @public (undocumented)
export class CompoundButton extends React.Component<IButtonProps, {}> {
    // (undocumented)
    render(): JSX.Element;
}

// @public
export function constructKeytip(configMap: IKeytipConfigMap, parentSequence: string[], keytip: IKeytipConfigItem): void;

// @public
export const ContextualMenu: React.FunctionComponent<IContextualMenuProps>;

// @public (undocumented)
export class ContextualMenuBase extends React.Component<IContextualMenuProps, IContextualMenuState> {
    constructor(props: IContextualMenuProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    static defaultProps: IContextualMenuProps;
    // (undocumented)
    dismiss: (ev?: any, dismissAll?: boolean | undefined) => void;
    // (undocumented)
    render(): JSX.Element | null;
    // (undocumented)
    shouldComponentUpdate(newProps: IContextualMenuProps, newState: IContextualMenuState): boolean;
    // (undocumented)
    UNSAFE_componentWillMount(): void;
    // (undocumented)
    UNSAFE_componentWillUpdate(newProps: IContextualMenuProps): void;
    }

// @public
export const ContextualMenuItem: React.FunctionComponent<IContextualMenuItemProps>;

// @public (undocumented)
export class ContextualMenuItemBase extends React.Component<IContextualMenuItemProps, {}> {
    constructor(props: IContextualMenuItemProps);
    // (undocumented)
    dismissMenu: (dismissAll?: boolean | undefined) => void;
    // (undocumented)
    dismissSubMenu: () => void;
    // (undocumented)
    openSubMenu: () => void;
    // (undocumented)
    render(): JSX.Element;
    }

// @public (undocumented)
export enum ContextualMenuItemType {
    // (undocumented)
    Divider = 1,
    // (undocumented)
    Header = 2,
    // (undocumented)
    Normal = 0,
    // (undocumented)
    Section = 3
}

// @public
export function correctHex(hex: string): string;

// @public
export function correctHSV(color: IHSV): IHSV;

// @public
export function correctRGB(color: IRGB): IRGB;

// @public (undocumented)
export function createGenericItem(name: string, currentValidationState: ValidationState): IGenericItem & {
    key: React.Key;
};

// @public (undocumented)
export function createItem(name: string, isValid: boolean): ISuggestionModel<IPersonaProps>;

// @public
export function cssColor(color?: string): IRGB | undefined;

// @public (undocumented)
export const DATAKTP_ARIA_TARGET = "data-ktp-aria-target";

// @public (undocumented)
export const DATAKTP_EXECUTE_TARGET = "data-ktp-execute-target";

// @public (undocumented)
export const DATAKTP_TARGET = "data-ktp-target";

// @public
export const DatePicker: React.FunctionComponent<IDatePickerProps>;

// @public (undocumented)
export class DatePickerBase extends React.Component<IDatePickerProps, IDatePickerState> implements IDatePicker {
    constructor(props: IDatePickerProps);
    // (undocumented)
    componentDidUpdate(prevProps: IDatePickerProps, prevState: IDatePickerState): void;
    // (undocumented)
    static defaultProps: IDatePickerProps;
    // (undocumented)
    focus(): void;
    // (undocumented)
    render(): JSX.Element;
    // (undocumented)
    reset(): void;
    // (undocumented)
    UNSAFE_componentWillReceiveProps(nextProps: IDatePickerProps): void;
    }

export { DateRangeType }

export { DayOfWeek }

// @public (undocumented)
export const DEFAULT_MASK_CHAR = "_";

// @public (undocumented)
export class DefaultButton extends React.Component<IButtonProps, {}> {
    // (undocumented)
    render(): JSX.Element;
}

// @public (undocumented)
export type DefaultProps = Required<Pick<ISpinButtonProps, 'step' | 'min' | 'max' | 'disabled' | 'labelPosition' | 'label' | 'incrementButtonIcon' | 'decrementButtonIcon'>>;

// @public (undocumented)
export const Dialog: React.FunctionComponent<IDialogProps>;

// @public (undocumented)
export class DialogBase extends React.Component<IDialogProps, {}> {
    constructor(props: IDialogProps);
    // (undocumented)
    static defaultProps: IDialogProps;
    // (undocumented)
    render(): JSX.Element;
}

// @public (undocumented)
export const DialogContent: React.FunctionComponent<IDialogContentProps>;

// @public (undocumented)
export class DialogContentBase extends React.Component<IDialogContentProps, {}> {
    constructor(props: IDialogContentProps);
    // (undocumented)
    static defaultProps: IDialogContentProps;
    // (undocumented)
    render(): JSX.Element;
}

// @public (undocumented)
export const DialogFooter: React.FunctionComponent<IDialogFooterProps>;

// @public (undocumented)
export class DialogFooterBase extends React.Component<IDialogFooterProps, {}> {
    constructor(props: IDialogFooterProps);
    // (undocumented)
    render(): JSX.Element;
    }

// @public (undocumented)
export enum DialogType {
    close = 2,
    largeHeader = 1,
    normal = 0
}

// @public (undocumented)
export const DirectionalHint: {
    topLeftEdge: 0;
    topCenter: 1;
    topRightEdge: 2;
    topAutoEdge: 3;
    bottomLeftEdge: 4;
    bottomCenter: 5;
    bottomRightEdge: 6;
    bottomAutoEdge: 7;
    leftTopEdge: 8;
    leftCenter: 9;
    leftBottomEdge: 10;
    rightTopEdge: 11;
    rightCenter: 12;
    rightBottomEdge: 13;
};

// @public (undocumented)
export type DirectionalHint = typeof DirectionalHint[keyof typeof DirectionalHint];

// @public (undocumented)
export class DragDropHelper implements IDragDropHelper {
    constructor(params: IDragDropHelperParams);
    // (undocumented)
    dispose(): void;
    // (undocumented)
    subscribe(root: HTMLElement, events: EventGroup, dragDropOptions: IDragDropOptions): {
        key: string;
        dispose(): void;
    };
    // (undocumented)
    unsubscribe(root: HTMLElement, key: string): void;
}

// @public (undocumented)
export enum ElementType {
    anchor = 1,
    button = 0
}

// @public (undocumented)
export const ExpandingCard: React.FunctionComponent<IExpandingCardProps>;

// @public (undocumented)
export class ExpandingCardBase extends React.Component<IExpandingCardProps, IExpandingCardState> {
    constructor(props: IExpandingCardProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    static defaultProps: {
        compactCardHeight: number;
        expandedCardHeight: number;
        directionalHintFixed: boolean;
    };
    // (undocumented)
    render(): JSX.Element;
}

// @public (undocumented)
export enum ExpandingCardMode {
    compact = 0,
    expanded = 1
}

// @public (undocumented)
export class ExtendedPeoplePicker extends BaseExtendedPeoplePicker {
}

// @public (undocumented)
export class ExtendedSelectedItem extends React.Component<ISelectedPeopleItemProps, IPeoplePickerItemState> {
    constructor(props: ISelectedPeopleItemProps);
    // (undocumented)
    protected persona: React.RefObject<HTMLDivElement>;
    // (undocumented)
    render(): JSX.Element;
}

// @public (undocumented)
export const Fabric: React.FunctionComponent<IFabricProps>;

// @public (undocumented)
export const FabricBase: React.FunctionComponent<IFabricProps>;

// @public (undocumented)
export enum FabricSlots {
    // (undocumented)
    black = 20,
    // (undocumented)
    neutralDark = 19,
    // (undocumented)
    neutralLight = 11,
    // (undocumented)
    neutralLighter = 10,
    // (undocumented)
    neutralLighterAlt = 9,
    // (undocumented)
    neutralPrimary = 18,
    // (undocumented)
    neutralPrimaryAlt = 17,
    // (undocumented)
    neutralQuaternary = 13,
    // (undocumented)
    neutralQuaternaryAlt = 12,
    // (undocumented)
    neutralSecondary = 16,
    // (undocumented)
    neutralTertiary = 15,
    // (undocumented)
    neutralTertiaryAlt = 14,
    // (undocumented)
    themeDark = 7,
    // (undocumented)
    themeDarkAlt = 6,
    // (undocumented)
    themeDarker = 8,
    // (undocumented)
    themeLight = 3,
    // (undocumented)
    themeLighter = 2,
    // (undocumented)
    themeLighterAlt = 1,
    // (undocumented)
    themePrimary = 0,
    // (undocumented)
    themeSecondary = 5,
    // (undocumented)
    themeTertiary = 4,
    // (undocumented)
    white = 21
}

// @public
export const Facepile: React.FunctionComponent<IFacepileProps>;

// @public
export class FacepileBase extends React.Component<IFacepileProps, {}> {
    constructor(props: IFacepileProps);
    // (undocumented)
    static defaultProps: IFacepileProps;
    // (undocumented)
    protected onRenderAriaDescription(): "" | JSX.Element | undefined;
    // (undocumented)
    render(): JSX.Element;
    }

export { FirstWeekOfYear }

// @public (undocumented)
export class FloatingPeoplePicker extends BaseFloatingPeoplePicker {
    // (undocumented)
    static defaultProps: any;
}

// @public
export const FocusTrapCallout: React.FunctionComponent<IFocusTrapCalloutProps>;

// @public (undocumented)
export class FocusTrapZone extends React.Component<IFocusTrapZoneProps, {}> implements IFocusTrapZone {
    constructor(props: IFocusTrapZoneProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentDidUpdate(prevProps: IFocusTrapZoneProps): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    focus(): void;
    // (undocumented)
    render(): JSX.Element;
    // (undocumented)
    UNSAFE_componentWillReceiveProps(nextProps: IFocusTrapZoneProps): void;
    }

// @public
export const FontIcon: React.FunctionComponent<IFontIconProps>;

// @public (undocumented)
export function getAllSelectedOptions(options: ISelectableOption[], selectedIndices: number[]): ISelectableOption[];

// @public
export function getAriaDescribedBy(keySequences: string[]): string;

// @public (undocumented)
export function getBackgroundShade(color: IColor, shade: Shade, isInverted?: boolean): IColor | null;

// @public (undocumented)
export function getBoundsFromTargetWindow(target: Element | MouseEvent | Point | null, targetWindow: IWindowWithSegments): IRectangle;

// @public
export function getColorFromHSV(hsv: IHSV, a?: number): IColor;

// @public
export function getColorFromRGBA(rgba: IRGB): IColor;

// @public
export function getColorFromString(inputColor: string): IColor | undefined;

// @public (undocumented)
export function getContrastRatio(color1: IColor, color2: IColor): number;

// @public
export const getFontIcon: (iconName: string, className?: string | undefined, ariaLabel?: string | undefined) => React.ReactElement<any, string | ((props: any) => React.ReactElement<any, string | any | (new (props: any) => React.Component<any, any, any>)> | null) | (new (props: any) => React.Component<any, any, any>)> | null;

// @public
export function getFullColorString(color: IColor): string;

// @public (undocumented)
export const getIconContent: (iconName?: string | undefined) => IIconContent | null;

// @public
export function getMaxHeight(target: Element | MouseEvent | Point, targetEdge: DirectionalHint, gapSpace?: number, bounds?: IRectangle, coverTarget?: boolean): number;

// @public
export const getMeasurementCache: () => {
    getCachedMeasurement: (data: any) => number | undefined;
    addMeasurementToCache: (data: any, measurement: number) => void;
};

// @public (undocumented)
export const getMenuItemStyles: (theme: ITheme) => IMenuItemStyles;

// @public
export const getNextResizeGroupStateProvider: (measurementCache?: {
    getCachedMeasurement: (data: any) => number | undefined;
    addMeasurementToCache: (data: any, measurement: number) => void;
}) => {
    getNextState: (props: IResizeGroupProps, currentState: IResizeGroupState, getElementToMeasureDimension: () => number, newContainerDimension?: number | undefined) => IResizeGroupState | undefined;
    shouldRenderDataForMeasurement: (dataToMeasure: any) => boolean;
    getInitialResizeGroupState: (data: any) => IResizeGroupState;
};

// @public
export function getOppositeEdge(edge: RectangleEdge): RectangleEdge;

// @public
export function getPersonaInitialsColor(props: Pick<IPersonaProps, 'primaryText' | 'text' | 'initialsColor'>): string;

// @public
export function getShade(color: IColor, shade: Shade, isInverted?: boolean): IColor | null;

// @public (undocumented)
export const getSplitButtonClassNames: (styles: IButtonStyles, disabled: boolean, expanded: boolean, checked: boolean, primaryDisabled?: boolean | undefined) => ISplitButtonClassNames;

// @public (undocumented)
export function getSubmenuItems(item: IContextualMenuItem): IContextualMenuItem[] | undefined;

// @public
export const HEX_REGEX: RegExp;

// @public (undocumented)
export const HoverCard: React.FunctionComponent<IHoverCardProps>;

// @public (undocumented)
export class HoverCardBase extends React.Component<IHoverCardProps, IHoverCardState> implements IHoverCard {
    constructor(props: IHoverCardProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentDidUpdate(prevProps: IHoverCardProps, prevState: IHoverCardState): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    static defaultProps: {
        cardOpenDelay: number;
        cardDismissDelay: number;
        expandedCardOpenDelay: number;
        instantOpenOnClick: boolean;
        setInitialFocus: boolean;
        openHotKey: number;
        type: HoverCardType;
    };
    // (undocumented)
    dismiss: (withTimeOut?: boolean | undefined) => void;
    // (undocumented)
    render(): JSX.Element;
    }

// @public (undocumented)
export enum HoverCardType {
    expanding = "ExpandingCard",
    plain = "PlainCard"
}

// @public
export function hsl2hsv(h: number, s: number, l: number): IHSV;

// @public
export function hsl2rgb(h: number, s: number, l: number): IRGB;

// @public
export function hsv2hex(h: number, s: number, v: number): string;

// @public
export function hsv2hsl(h: number, s: number, v: number): IHSL;

// @public
export function hsv2rgb(h: number, s: number, v: number): IRGB;

// @public (undocumented)
export interface IAccessiblePopupProps {
    closeButtonAriaLabel?: string;
    elementToFocusOnDismiss?: HTMLElement;
    firstFocusableSelector?: string | (() => string);
    forceFocusInsideTrap?: boolean;
    ignoreExternalFocusing?: boolean;
    isClickableOutsideFocusTrap?: boolean;
}

// @public (undocumented)
export interface IActivityItemProps extends React.AllHTMLAttributes<HTMLElement> {
    activityDescription?: React.ReactNode[] | React.ReactNode;
    // @deprecated
    activityDescriptionText?: string;
    activityIcon?: React.ReactNode;
    activityPersonas?: Array<IPersonaSharedProps>;
    animateBeaconSignal?: boolean;
    beaconColorOne?: string;
    beaconColorTwo?: string;
    comments?: React.ReactNode[] | React.ReactNode;
    // @deprecated
    commentText?: string;
    isCompact?: boolean;
    onRenderActivityDescription?: IRenderFunction<IActivityItemProps>;
    onRenderComments?: IRenderFunction<IActivityItemProps>;
    onRenderIcon?: IRenderFunction<IActivityItemProps>;
    onRenderTimeStamp?: IRenderFunction<IActivityItemProps>;
    styles?: IActivityItemStyles;
    timeStamp?: string | React.ReactNode[] | React.ReactNode;
}

// @public (undocumented)
export interface IActivityItemStyles {
    activityContent?: IStyle;
    activityPersona?: IStyle;
    activityText?: IStyle;
    activityTypeIcon?: IStyle;
    commentText?: IStyle;
    doublePersona?: IStyle;
    isCompactContent?: IStyle;
    isCompactIcon?: IStyle;
    isCompactPersona?: IStyle;
    isCompactPersonaContainer?: IStyle;
    isCompactRoot?: IStyle;
    isCompactTimeStamp?: IStyle;
    personaContainer?: IStyle;
    pulsingBeacon?: IStyle;
    root?: IStyle;
    timeStamp?: IStyle;
}

// @public (undocumented)
export interface IAnnouncedProps extends React.Props<AnnouncedBase>, React.HTMLAttributes<HTMLDivElement> {
    'aria-live'?: 'off' | 'polite' | 'assertive';
    as?: React.ElementType;
    message?: string;
    styles?: IStyleFunctionOrObject<{}, IAnnouncedStyles>;
}

// @public (undocumented)
export type IAnnouncedStyleProps = Pick<IAnnouncedProps, 'className'>;

// @public (undocumented)
export interface IAnnouncedStyles {
    root: IStyle;
    screenReaderText: IStyle;
}

// @public (undocumented)
export interface IAutofill {
    clear(): void;
    cursorLocation: number | null;
    focus(): void;
    inputElement: HTMLInputElement | null;
    isValueSelected: boolean;
    selectionEnd: number | null;
    selectionStart: number | null;
    value: string;
}

// @public (undocumented)
export interface IAutofillProps extends React.InputHTMLAttributes<HTMLInputElement | Autofill> {
    componentRef?: IRefObject<IAutofill>;
    defaultVisibleValue?: string;
    enableAutofillOnKeyPress?: KeyCodes[];
    onInputChange?: (value: string, composing: boolean) => string;
    onInputValueChange?: (newValue?: string, composing?: boolean) => void;
    preventValueSelection?: boolean;
    shouldSelectFullInputValueInComponentDidUpdate?: () => boolean;
    suggestedDisplayValue?: string;
    updateValueInWillReceiveProps?: () => string | null;
}

// @public (undocumented)
export interface IAutofillState {
    // (undocumented)
    displayValue?: string;
}

// @public @deprecated
export interface IBaseAutoFill extends IAutofill {
}

// @public @deprecated
export interface IBaseAutoFillProps extends IAutofillProps {
}

// @public (undocumented)
export interface IBaseButtonProps extends IButtonProps {
    // (undocumented)
    baseClassName?: string;
    // (undocumented)
    variantClassName?: string;
}

// @public (undocumented)
export interface IBaseButtonState {
    // (undocumented)
    menuHidden: boolean;
}

// @public (undocumented)
export interface IBaseExtendedPicker<T> {
    focus: () => void;
    forceResolve?: () => void;
    items: T[] | undefined;
}

// @public (undocumented)
export interface IBaseExtendedPickerProps<T> {
    className?: string;
    componentRef?: IRefObject<IBaseExtendedPicker<T>>;
    currentRenderedQueryString?: string;
    defaultSelectedItems?: T[];
    disabled?: boolean;
    floatingPickerProps: IBaseFloatingPickerProps<T>;
    focusZoneProps?: IFocusZoneProps;
    headerComponent?: JSX.Element;
    inputProps?: IInputProps;
    itemLimit?: number;
    onBlur?: React.FocusEventHandler<HTMLInputElement | Autofill>;
    onChange?: (items?: T[]) => void;
    onFocus?: React.FocusEventHandler<HTMLInputElement | Autofill>;
    onItemAdded?: (addedItem: T) => void;
    onItemSelected?: (selectedItem?: T) => T | PromiseLike<T>;
    onItemsRemoved?: (removedItems: T[]) => void;
    onPaste?: (pastedText: string) => T[];
    onRenderFloatingPicker: React.ComponentType<IBaseFloatingPickerProps<T>>;
    onRenderSelectedItems: React.ComponentType<IBaseSelectedItemsListProps<T>>;
    selectedItems?: T[];
    selectedItemsListProps: IBaseSelectedItemsListProps<T>;
    suggestionItems?: T[];
}

// @public (undocumented)
export interface IBaseExtendedPickerState<T> {
    // (undocumented)
    queryString: string | null;
    // (undocumented)
    selectedItems: T[] | null;
    // (undocumented)
    suggestionItems: T[] | null;
}

// @public (undocumented)
export interface IBaseFloatingPicker {
    hidePicker: () => void;
    inputText: string;
    isSuggestionsShown: boolean;
    onQueryStringChanged: (input: string) => void;
    showPicker: (updateValue?: boolean) => void;
    suggestions: any[];
}

// @public (undocumented)
export interface IBaseFloatingPickerProps<T> extends React.ClassAttributes<any> {
    calloutWidth?: number;
    className?: string;
    // (undocumented)
    componentRef?: IRefObject<IBaseFloatingPicker>;
    createGenericItem?: (input: string, isValid: boolean) => ISuggestionModel<T>;
    getTextFromItem?: (item: T, currentValue?: string) => string;
    inputElement?: HTMLInputElement | null;
    onChange?: (item: T) => void;
    onInputChanged?: (filter: string) => void;
    onRemoveSuggestion?: (item: T) => void;
    onRenderSuggestionsItem?: (props: T, itemProps: ISuggestionItemProps<T>) => JSX.Element;
    onResolveSuggestions: (filter: string, selectedItems?: T[]) => T[] | PromiseLike<T[]> | null;
    onSuggestionsHidden?: () => void;
    onSuggestionsShown?: () => void;
    onValidateInput?: (input: string) => boolean;
    onZeroQuerySuggestion?: (selectedItems?: T[]) => T[] | PromiseLike<T[]> | null;
    pickerCalloutProps?: ICalloutProps;
    pickerSuggestionsProps?: IBaseFloatingPickerSuggestionProps;
    resolveDelay?: number;
    searchingText?: ((props: {
        input: string;
    }) => string) | string;
    selectedItems?: T[];
    showForceResolve?: () => boolean;
    suggestionItems?: T[];
    suggestionsStore: SuggestionsStore<T>;
}

// @public (undocumented)
export interface IBaseFloatingPickerState {
    // (undocumented)
    didBind: boolean;
    // (undocumented)
    queryString: string;
    // (undocumented)
    suggestionsVisible?: boolean;
}

// @public
export type IBaseFloatingPickerSuggestionProps = Pick<ISuggestionsControlProps<any>, 'shouldSelectFirstItem' | 'headerItemsProps' | 'footerItemsProps' | 'showRemoveButtons'>;

// @public
export interface IBasePicker<T> {
    completeSuggestion: (forceComplete?: boolean) => void;
    focus: () => void;
    focusInput: () => void;
    items: T[] | undefined;
}

// @public
export interface IBasePickerProps<T> extends React.Props<any> {
    className?: string;
    componentRef?: IRefObject<IBasePicker<T>>;
    createGenericItem?: (input: string, ValidationState: ValidationState) => ISuggestionModel<T> | T;
    defaultSelectedItems?: T[];
    disabled?: boolean;
    enableSelectedSuggestionAlert?: boolean;
    getTextFromItem?: (item: T, currentValue?: string) => string;
    inputProps?: IInputProps;
    itemLimit?: number;
    onBlur?: React.FocusEventHandler<HTMLInputElement | Autofill>;
    onChange?: (items?: T[]) => void;
    onDismiss?: (ev?: any, selectedItem?: T) => boolean | void;
    // @deprecated
    onEmptyInputFocus?: (selectedItems?: T[]) => T[] | PromiseLike<T[]>;
    onEmptyResolveSuggestions?: (selectedItems?: T[]) => T[] | PromiseLike<T[]>;
    // @deprecated
    onFocus?: React.FocusEventHandler<HTMLInputElement | Autofill>;
    onGetMoreResults?: (filter: string, selectedItems?: T[]) => T[] | PromiseLike<T[]>;
    onInputChange?: (input: string) => string;
    onItemSelected?: (selectedItem?: T) => T | PromiseLike<T> | null;
    onRemoveSuggestion?: (item: T) => void;
    onRenderItem?: (props: IPickerItemProps<T>) => JSX.Element;
    onRenderSuggestionsItem?: (props: T, itemProps: ISuggestionItemProps<T>) => JSX.Element;
    onResolveSuggestions: (filter: string, selectedItems?: T[]) => T[] | PromiseLike<T[]>;
    onValidateInput?: (input: string) => ValidationState;
    pickerCalloutProps?: ICalloutProps;
    pickerSuggestionsProps?: IBasePickerSuggestionsProps;
    removeButtonAriaLabel?: string;
    resolveDelay?: number;
    searchingText?: ((props: {
        input: string;
    }) => string) | string;
    selectedItems?: T[];
    styles?: IStyleFunctionOrObject<IBasePickerStyleProps, IBasePickerStyles>;
    theme?: ITheme;
}

// @public (undocumented)
export interface IBasePickerState {
    // (undocumented)
    isFocused?: boolean;
    // (undocumented)
    isMostRecentlyUsedVisible?: boolean;
    // (undocumented)
    isResultsFooterVisible?: boolean;
    // (undocumented)
    isSearching?: boolean;
    // (undocumented)
    items?: any;
    // (undocumented)
    moreSuggestionsAvailable?: boolean;
    // (undocumented)
    selectedIndices?: number[];
    // (undocumented)
    suggestedDisplayValue?: string;
    // (undocumented)
    suggestionsLoading?: boolean;
    // (undocumented)
    suggestionsVisible?: boolean;
}

// @public
export type IBasePickerStyleProps = Pick<IBasePickerProps<any>, 'theme' | 'className' | 'disabled'> & {
    isFocused?: boolean;
    inputClassName?: string;
};

// @public
export interface IBasePickerStyles {
    input: IStyle;
    itemsWrapper: IStyle;
    root: IStyle;
    screenReaderText: IStyle;
    text: IStyle;
}

// @public
export interface IBasePickerSuggestionsProps<T = any> extends Pick<ISuggestionsProps<T>, 'onRenderNoResultFound' | 'suggestionsHeaderText' | 'mostRecentlyUsedHeaderText' | 'noResultsFoundText' | 'className' | 'suggestionsClassName' | 'suggestionsItemClassName' | 'searchForMoreText' | 'forceResolveText' | 'loadingText' | 'searchingText' | 'resultsFooterFull' | 'resultsFooter' | 'resultsMaximumNumber' | 'showRemoveButtons' | 'suggestionsAvailableAlertText' | 'suggestionsContainerAriaLabel' | 'showForceResolve'> {
}

// @public (undocumented)
export interface IBaseSelectedItemsList<T> {
    // (undocumented)
    addItems: (items: T[]) => void;
    items: T[] | undefined;
}

// @public (undocumented)
export interface IBaseSelectedItemsListProps<T> extends React.ClassAttributes<any> {
    canRemoveItem?: (item: T) => boolean;
    // (undocumented)
    componentRef?: IRefObject<IBaseSelectedItemsList<T>>;
    createGenericItem?: (input: string, ValidationState: ValidationState) => ISuggestionModel<T>;
    defaultSelectedItems?: T[];
    onChange?: (items?: T[]) => void;
    onCopyItems?: (items: T[]) => string;
    // @deprecated
    onItemDeleted?: (deletedItem: T) => void;
    onItemsDeleted?: (deletedItems: T[]) => void;
    onItemSelected?: (selectedItem?: T) => T | PromiseLike<T>;
    onRenderItem?: (props: ISelectedItemProps<T>) => JSX.Element;
    removeButtonAriaLabel?: string;
    selectedItems?: T[];
    selection?: Selection;
}

// @public (undocumented)
export interface IBaseSelectedItemsListState<T = any> {
    // (undocumented)
    items: T[];
}

// @public (undocumented)
export interface IButton {
    dismissMenu: () => void;
    focus: () => void;
    openMenu: (shouldFocusOnContainer?: boolean, shouldFocusOnMount?: boolean) => void;
}

// @public (undocumented)
export interface IButtonGrid {
}

// @public (undocumented)
export interface IButtonGridCellProps<T> {
    cellDisabledStyle?: string[];
    cellIsSelectedStyle?: string[];
    className?: string;
    disabled?: boolean;
    // Warning: (ae-forgotten-export) The symbol "IButtonClassNames" needs to be exported by the entry point index.d.ts
    getClassNames?: (theme: ITheme, className: string, variantClassName: string, iconClassName: string | undefined, menuIconClassName: string | undefined, disabled: boolean, checked: boolean, expanded: boolean, isSplit: boolean | undefined) => IButtonClassNames;
    id: string;
    index?: number;
    item: T;
    label?: string;
    onClick?: (item: T) => void;
    onFocus?: (item: T) => void;
    onHover?: (item?: T) => void;
    onKeyDown?: (ev: React.KeyboardEvent<HTMLButtonElement>) => void;
    onMouseEnter?: (ev: React.MouseEvent<HTMLButtonElement>) => boolean;
    onMouseLeave?: (ev: React.MouseEvent<HTMLButtonElement>) => void;
    onMouseMove?: (ev: React.MouseEvent<HTMLButtonElement>) => boolean;
    onRenderItem: (item: T) => JSX.Element;
    onWheel?: (ev: React.MouseEvent<HTMLButtonElement>) => void;
    role?: string;
    selected?: boolean;
}

// @public (undocumented)
export interface IButtonGridProps extends React.TableHTMLAttributes<HTMLTableElement>, React.RefAttributes<HTMLElement> {
    ariaPosInSet?: number;
    ariaSetSize?: number;
    columnCount: number;
    componentRef?: IRefObject<IButtonGrid>;
    // @deprecated
    containerClassName?: string;
    doNotContainWithinFocusZone?: boolean;
    items: any[];
    onBlur?: () => void;
    onRenderItem: (item: any, index: number) => JSX.Element;
    // @deprecated (undocumented)
    positionInSet?: number;
    // @deprecated (undocumented)
    setSize?: number;
    shouldFocusCircularNavigate?: boolean;
    styles?: IStyleFunctionOrObject<IButtonGridStyleProps, IButtonGridStyles>;
    theme?: ITheme;
}

// @public
export interface IButtonGridStyleProps {
    theme: ITheme;
}

// @public
export interface IButtonGridStyles {
    focusedContainer?: IStyle;
    root: IStyle;
    tableCell: IStyle;
}

// @public (undocumented)
export interface IButtonProps extends React.AllHTMLAttributes<HTMLAnchorElement | HTMLButtonElement | HTMLDivElement | BaseButton | Button | HTMLSpanElement> {
    allowDisabledFocus?: boolean;
    ariaDescription?: string;
    ariaHidden?: boolean;
    ariaLabel?: string;
    // @deprecated
    buttonType?: ButtonType;
    checked?: boolean;
    className?: string;
    componentRef?: IRefObject<IButton>;
    data?: any;
    defaultRender?: any;
    // @deprecated
    description?: IStyle;
    disabled?: boolean;
    // @deprecated
    elementRef?: React.Ref<HTMLElement>;
    getClassNames?: (theme: ITheme, className: string, variantClassName: string, iconClassName: string | undefined, menuIconClassName: string | undefined, disabled: boolean, checked: boolean, expanded: boolean, hasMenu: boolean, isSplit: boolean | undefined, allowDisabledFocus: boolean) => IButtonClassNames;
    getSplitButtonClassNames?: (disabled: boolean, expanded: boolean, checked: boolean, allowDisabledFocus: boolean) => ISplitButtonClassNames;
    href?: string;
    iconProps?: IIconProps;
    keytipProps?: IKeytipProps;
    menuAs?: IComponentAs<IContextualMenuProps>;
    menuIconProps?: IIconProps;
    menuProps?: IContextualMenuProps;
    menuTriggerKeyCode?: KeyCodes | null;
    onAfterMenuDismiss?: () => void;
    onMenuClick?: (ev?: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>, button?: IButtonProps) => void;
    onRenderAriaDescription?: IRenderFunction<IButtonProps>;
    onRenderChildren?: IRenderFunction<IButtonProps>;
    onRenderDescription?: IRenderFunction<IButtonProps>;
    onRenderIcon?: IRenderFunction<IButtonProps>;
    // @deprecated
    onRenderMenu?: IRenderFunction<IContextualMenuProps>;
    onRenderMenuIcon?: IRenderFunction<IButtonProps>;
    onRenderText?: IRenderFunction<IButtonProps>;
    persistMenu?: boolean;
    primary?: boolean;
    primaryActionButtonProps?: IButtonProps;
    primaryDisabled?: boolean;
    // @deprecated
    renderPersistedMenuHiddenOnMount?: boolean;
    // @deprecated
    rootProps?: React.ButtonHTMLAttributes<HTMLButtonElement> | React.AnchorHTMLAttributes<HTMLAnchorElement>;
    secondaryText?: string;
    split?: boolean;
    splitButtonAriaLabel?: string;
    splitButtonMenuProps?: IButtonProps;
    styles?: IButtonStyles;
    text?: string;
    theme?: ITheme;
    toggle?: boolean;
    // @deprecated
    toggled?: boolean;
    uniqueId?: string | number;
}

// @public (undocumented)
export interface IButtonStyles {
    description?: IStyle;
    descriptionChecked?: IStyle;
    descriptionDisabled?: IStyle;
    descriptionHovered?: IStyle;
    descriptionPressed?: IStyle;
    flexContainer?: IStyle;
    icon?: IStyle;
    iconChecked?: IStyle;
    iconDisabled?: IStyle;
    iconExpanded?: IStyle;
    iconExpandedHovered?: IStyle;
    iconHovered?: IStyle;
    iconPressed?: IStyle;
    label?: IStyle;
    labelChecked?: IStyle;
    labelDisabled?: IStyle;
    labelHovered?: IStyle;
    menuIcon?: IStyle;
    menuIconChecked?: IStyle;
    menuIconDisabled?: IStyle;
    menuIconExpanded?: IStyle;
    menuIconExpandedHovered?: IStyle;
    menuIconHovered?: IStyle;
    menuIconPressed?: IStyle;
    root?: IStyle;
    rootChecked?: IStyle;
    rootCheckedDisabled?: IStyle;
    rootCheckedHovered?: IStyle;
    rootCheckedPressed?: IStyle;
    rootDisabled?: IStyle;
    rootExpanded?: IStyle;
    rootExpandedHovered?: IStyle;
    rootFocused?: IStyle;
    rootHasMenu?: IStyle;
    rootHovered?: IStyle;
    rootPressed?: IStyle;
    screenReaderText?: IStyle;
    secondaryText?: IStyle;
    splitButtonContainer?: IStyle;
    splitButtonContainerChecked?: IStyle;
    splitButtonContainerCheckedHovered?: IStyle;
    splitButtonContainerDisabled?: IStyle;
    splitButtonContainerFocused?: IStyle;
    splitButtonContainerHovered?: IStyle;
    splitButtonDivider?: IStyle;
    splitButtonDividerDisabled?: IStyle;
    splitButtonFlexContainer?: IStyle;
    splitButtonMenuButton?: IStyle;
    splitButtonMenuButtonChecked?: IStyle;
    splitButtonMenuButtonDisabled?: IStyle;
    splitButtonMenuButtonExpanded?: IStyle;
    splitButtonMenuIcon?: IStyle;
    splitButtonMenuIconDisabled?: IStyle;
    textContainer?: IStyle;
}

// @public (undocumented)
export interface ICalendar {
    focus: () => void;
}

// @public (undocumented)
export interface ICalendarFormatDateCallbacks {
    formatDay: (date: Date) => string;
    formatMonthDayYear: (date: Date, strings?: ICalendarStrings) => string;
    formatMonthYear: (date: Date, strings?: ICalendarStrings) => string;
    formatYear: (date: Date) => string;
}

// @public (undocumented)
export interface ICalendarIconStrings {
    closeIcon?: string;
    leftNavigation?: string;
    rightNavigation?: string;
}

// @public (undocumented)
export interface ICalendarProps extends IBaseProps<ICalendar>, React.HTMLAttributes<HTMLElement> {
    allFocusable?: boolean;
    autoNavigateOnSelection?: boolean;
    className?: string;
    componentRef?: IRefObject<ICalendar>;
    dateRangeType?: DateRangeType;
    dateTimeFormatter?: ICalendarFormatDateCallbacks;
    firstDayOfWeek?: DayOfWeek;
    firstWeekOfYear?: FirstWeekOfYear;
    highlightCurrentMonth?: boolean;
    highlightSelectedMonth?: boolean;
    isDayPickerVisible?: boolean;
    isMonthPickerVisible?: boolean;
    maxDate?: Date;
    minDate?: Date;
    navigationIcons?: ICalendarIconStrings;
    onDismiss?: () => void;
    onSelectDate?: (date: Date, selectedDateRangeArray?: Date[]) => void;
    restrictedDates?: Date[];
    selectDateOnClick?: boolean;
    // @deprecated
    shouldFocusOnMount?: boolean;
    showCloseButton?: boolean;
    showGoToToday?: boolean;
    showMonthPickerAsOverlay?: boolean;
    showSixWeeksByDefault?: boolean;
    showWeekNumbers?: boolean;
    strings: ICalendarStrings | null;
    today?: Date;
    value?: Date;
    workWeekDays?: DayOfWeek[];
    yearPickerHidden?: boolean;
}

// @public (undocumented)
export interface ICalendarState {
    isDayPickerVisible?: boolean;
    isMonthPickerVisible?: boolean;
    navigatedDayDate?: Date;
    navigatedMonthDate?: Date;
    selectedDate?: Date;
}

// @public (undocumented)
export interface ICalendarStrings {
    closeButtonAriaLabel?: string;
    days: string[];
    goToToday: string;
    monthPickerHeaderAriaLabel?: string;
    months: string[];
    nextMonthAriaLabel?: string;
    nextYearAriaLabel?: string;
    nextYearRangeAriaLabel?: string;
    prevMonthAriaLabel?: string;
    prevYearAriaLabel?: string;
    prevYearRangeAriaLabel?: string;
    shortDays: string[];
    shortMonths: string[];
    weekNumberFormatString?: string;
    yearPickerHeaderAriaLabel?: string;
}

// @public (undocumented)
export interface ICalloutBeakPositionedInfo extends IPositionedData {
    // (undocumented)
    closestEdge: RectangleEdge;
}

// @public (undocumented)
export interface ICalloutContentStyleProps {
    backgroundColor?: string;
    beakWidth?: number;
    calloutMaxWidth?: number;
    calloutWidth?: number;
    className?: string;
    overflowYHidden?: boolean;
    positions?: ICalloutPositionedInfo;
    theme: ITheme;
}

// @public (undocumented)
export interface ICalloutContentStyles {
    beak: IStyle;
    beakCurtain: IStyle;
    calloutMain: IStyle;
    container: IStyle;
    root: IStyle;
}

// @public (undocumented)
export interface ICalloutPositionedInfo extends IPositionedData {
    // (undocumented)
    beakPosition: ICalloutBeakPositionedInfo;
}

// @public (undocumented)
export interface ICalloutPositionProps extends IPositionProps {
    beakWidth?: number;
    isBeakVisible?: boolean;
}

// @public (undocumented)
export interface ICalloutProps extends React.HTMLAttributes<HTMLDivElement> {
    alignTargetEdge?: boolean;
    ariaDescribedBy?: string;
    ariaLabel?: string;
    ariaLabelledBy?: string;
    backgroundColor?: string;
    beakWidth?: number;
    bounds?: IRectangle | ((target?: Target, targetWindow?: Window) => IRectangle | undefined);
    calloutMaxHeight?: number;
    calloutMaxWidth?: number;
    calloutWidth?: number;
    className?: string;
    coverTarget?: boolean;
    directionalHint?: DirectionalHint;
    directionalHintFixed?: boolean;
    directionalHintForRTL?: DirectionalHint;
    dismissOnTargetClick?: boolean;
    doNotLayer?: boolean;
    finalHeight?: number;
    gapSpace?: number;
    hidden?: boolean;
    hideOverflow?: boolean;
    isBeakVisible?: boolean;
    layerProps?: ILayerProps;
    minPagePadding?: number;
    onDismiss?: (ev?: any) => void;
    onLayerMounted?: () => void;
    onPositioned?: (positions?: ICalloutPositionedInfo) => void;
    onRestoreFocus?: (options: {
        originalElement?: HTMLElement | Window;
        containsFocus: boolean;
        documentContainsFocus: boolean;
    }) => void;
    onScroll?: () => void;
    preventDismissOnEvent?: (ev: Event | React.FocusEvent | React.KeyboardEvent | React.MouseEvent) => boolean;
    // @deprecated
    preventDismissOnLostFocus?: boolean;
    // @deprecated
    preventDismissOnResize?: boolean;
    // @deprecated
    preventDismissOnScroll?: boolean;
    role?: string;
    setInitialFocus?: boolean;
    shouldDismissOnWindowFocus?: boolean;
    // @deprecated
    shouldRestoreFocus?: boolean;
    shouldUpdateWhenHidden?: boolean;
    style?: React.CSSProperties;
    styles?: IStyleFunctionOrObject<ICalloutContentStyleProps, ICalloutContentStyles>;
    target?: Target;
    theme?: ITheme;
}

// @public (undocumented)
export interface ICheckProps {
    // @deprecated (undocumented)
    alwaysShowCheck?: boolean;
    checked?: boolean;
    className?: string;
    componentRef?: IRefObject<ICheckProps>;
    styles?: IStyleFunctionOrObject<ICheckStyleProps, ICheckStyles>;
    theme?: ITheme;
    useFastIcons?: boolean;
}

// @public (undocumented)
export type ICheckStyleProps = Required<Pick<ICheckProps, 'theme'>> & Pick<ICheckProps, 'className' | 'checked'> & {
    height?: string;
    checkBoxHeight?: string;
};

// @public (undocumented)
export interface ICheckStyles {
    check: IStyle;
    // @deprecated
    checkHost: IStyle;
    circle: IStyle;
    root: IStyle;
}

// @public (undocumented)
export interface IChoiceGroup {
    checkedOption: IChoiceGroupOption | undefined;
    focus: () => void;
}

// @public (undocumented)
export interface IChoiceGroupOption extends React.InputHTMLAttributes<HTMLElement | HTMLInputElement> {
    ariaLabel?: string;
    // @deprecated
    checked?: boolean;
    disabled?: boolean;
    iconProps?: IIconProps;
    id?: string;
    imageAlt?: string;
    imageSize?: {
        width: number;
        height: number;
    };
    imageSrc?: string;
    key?: string;
    labelId?: string;
    onRenderField?: IRenderFunction<IChoiceGroupOption>;
    onRenderLabel?: IRenderFunction<IChoiceGroupOption>;
    selectedImageSrc?: string;
    styles?: IStyleFunctionOrObject<IChoiceGroupOptionStyleProps, IChoiceGroupOptionStyles>;
    text: string;
}

// @public (undocumented)
export interface IChoiceGroupOptionProps extends Omit<IChoiceGroupOption, 'key'> {
    componentRef?: IRefObject<IChoiceGroupOption>;
    focused?: boolean;
    // (undocumented)
    itemKey?: string;
    name?: string;
    onBlur?: (ev: React.FocusEvent<HTMLElement>, props?: IChoiceGroupOption) => void;
    onChange?: (evt?: React.FormEvent<HTMLElement | HTMLInputElement>, props?: IChoiceGroupOption) => void;
    onFocus?: (ev?: React.FocusEvent<HTMLElement | HTMLInputElement>, props?: IChoiceGroupOption) => void | undefined;
    required?: boolean;
    theme?: ITheme;
}

// @public
export interface IChoiceGroupOptionStyleProps {
    checked?: boolean;
    disabled?: boolean;
    focused?: boolean;
    hasIcon?: boolean;
    hasImage?: boolean;
    imageIsLarge?: boolean;
    imageSize?: {
        height: number;
        width: number;
    };
    theme: ITheme;
}

// @public (undocumented)
export interface IChoiceGroupOptionStyles {
    // (undocumented)
    choiceFieldWrapper?: IStyle;
    // (undocumented)
    field?: IStyle;
    // (undocumented)
    iconWrapper?: IStyle;
    // (undocumented)
    imageWrapper?: IStyle;
    // (undocumented)
    innerField?: IStyle;
    // (undocumented)
    input?: IStyle;
    // (undocumented)
    labelWrapper?: IStyle;
    // (undocumented)
    root?: IStyle;
    // (undocumented)
    selectedImageWrapper?: IStyle;
}

// @public (undocumented)
export interface IChoiceGroupProps extends React.InputHTMLAttributes<HTMLElement | HTMLInputElement>, React.RefAttributes<HTMLDivElement> {
    ariaLabelledBy?: string;
    componentRef?: IRefObject<IChoiceGroup>;
    defaultSelectedKey?: string | number;
    label?: string;
    onChange?: (ev?: React.FormEvent<HTMLElement | HTMLInputElement>, option?: IChoiceGroupOption) => void;
    options?: IChoiceGroupOption[];
    selectedKey?: string | number;
    styles?: IStyleFunctionOrObject<IChoiceGroupStyleProps, IChoiceGroupStyles>;
    theme?: ITheme;
}

// @public (undocumented)
export interface IChoiceGroupStyleProps {
    // (undocumented)
    className?: string;
    // (undocumented)
    optionsContainIconOrImage?: boolean;
    // (undocumented)
    theme: ITheme;
}

// @public (undocumented)
export interface IChoiceGroupStyles {
    // (undocumented)
    flexContainer?: IStyle;
    // (undocumented)
    label?: IStyle;
    // (undocumented)
    root?: IStyle;
}

// @public
export interface ICircle extends IShimmerElement {
    height?: number;
}

// @public (undocumented)
export interface ICoachmark {
    dismiss?: (ev?: Event | React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>) => void;
}

// @public
export interface ICoachmarkProps extends React.RefAttributes<HTMLDivElement> {
    ariaAlertText?: string;
    ariaDescribedBy?: string;
    ariaDescribedByText?: string;
    ariaLabelledBy?: string;
    ariaLabelledByText?: string;
    beaconColorOne?: string;
    beaconColorTwo?: string;
    // @deprecated
    beakHeight?: number;
    // @deprecated
    beakWidth?: number;
    children?: React.ReactNode;
    className?: string;
    // @deprecated
    collapsed?: boolean;
    color?: string;
    componentRef?: IRefObject<ICoachmark>;
    delayBeforeCoachmarkAnimation?: number;
    delayBeforeMouseOpen?: number;
    // @deprecated
    height?: number;
    isCollapsed?: boolean;
    isPositionForced?: boolean;
    mouseProximityOffset?: number;
    onAnimationOpenEnd?: () => void;
    onAnimationOpenStart?: () => void;
    onDismiss?: (ev?: Event | React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>) => void;
    onMouseMove?: (e: MouseEvent) => void;
    persistentBeak?: boolean;
    positioningContainerProps?: IPositioningContainerProps;
    preventDismissOnLostFocus?: boolean;
    preventFocusOnMount?: boolean;
    styles?: IStyleFunctionOrObject<ICoachmarkStyleProps, ICoachmarkStyles>;
    target: HTMLElement | string | null;
    // @deprecated
    teachingBubbleRef?: ITeachingBubble;
    theme?: ITheme;
    // @deprecated
    width?: number;
}

// @public
export interface ICoachmarkStyleProps {
    beaconColorOne?: string;
    beaconColorTwo?: string;
    className?: string;
    // @deprecated
    collapsed?: boolean;
    color?: string;
    delayBeforeCoachmarkAnimation?: string;
    entityHostHeight?: string;
    entityHostWidth?: string;
    height?: string;
    isCollapsed: boolean;
    isMeasuring: boolean;
    theme?: ITheme;
    transformOrigin?: string;
    width?: string;
}

// @public
export interface ICoachmarkStyles {
    ariaContainer?: IStyle;
    childrenContainer: IStyle;
    collapsed?: IStyle;
    entityHost?: IStyle;
    entityInnerHost: IStyle;
    pulsingBeacon?: IStyle;
    root?: IStyle;
    rotateAnimationLayer?: IStyle;
    scaleAnimationLayer?: IStyle;
    translateAnimationContainer?: IStyle;
}

// @public @deprecated (undocumented)
export type ICoachmarkTypes = ICoachmarkProps;

// @public (undocumented)
export interface IColor extends IRGB, IHSV {
    hex: string;
    str: string;
    t?: number;
}

// @public (undocumented)
export interface IColorCellProps {
    color: string;
    id: string;
    index?: number;
    label?: string;
}

// @public (undocumented)
export interface IColorPicker {
    color: IColor;
}

// @public (undocumented)
export interface IColorPickerGridCellProps {
    borderWidth?: number;
    circle?: boolean;
    color: string;
    disabled?: boolean;
    height?: number;
    // @deprecated
    id?: string;
    idPrefix?: string;
    index?: number;
    item: IColorCellProps;
    label?: string;
    onClick?: (item: IColorCellProps) => void;
    // (undocumented)
    onFocus?: (item: IColorCellProps) => void;
    // (undocumented)
    onHover?: (item?: IColorCellProps) => void;
    // (undocumented)
    onKeyDown?: (ev: React.KeyboardEvent<HTMLButtonElement>) => void;
    onMouseEnter?: (ev: React.MouseEvent<HTMLButtonElement>) => boolean;
    // (undocumented)
    onMouseLeave?: (ev: React.MouseEvent<HTMLButtonElement>) => void;
    onMouseMove?: (ev: React.MouseEvent<HTMLButtonElement>) => boolean;
    // (undocumented)
    onWheel?: (ev: React.MouseEvent<HTMLButtonElement>) => void;
    selected: boolean;
    styles?: IStyleFunctionOrObject<IColorPickerGridCellStyleProps, IColorPickerGridCellStyles>;
    theme?: ITheme;
    width?: number;
}

// @public (undocumented)
export interface IColorPickerGridCellStyleProps {
    borderWidth?: number;
    circle?: boolean;
    disabled?: boolean;
    height?: number;
    isWhite?: boolean;
    selected?: boolean;
    theme: ITheme;
    width?: number;
}

// @public (undocumented)
export interface IColorPickerGridCellStyles {
    colorCell: IStyle;
    svg: IStyle;
}

// @public (undocumented)
export interface IColorPickerProps {
    // @deprecated
    alphaLabel?: string;
    // @deprecated
    alphaSliderHidden?: boolean;
    alphaType?: 'alpha' | 'transparency' | 'none';
    // @deprecated
    blueLabel?: string;
    className?: string;
    color: IColor | string;
    componentRef?: IRefObject<IColorPicker>;
    // @deprecated
    greenLabel?: string;
    // @deprecated
    hexLabel?: string;
    onChange?: (ev: React.SyntheticEvent<HTMLElement>, color: IColor) => void;
    // @deprecated
    redLabel?: string;
    showPreview?: boolean;
    strings?: IColorPickerStrings;
    styles?: IStyleFunctionOrObject<IColorPickerStyleProps, IColorPickerStyles>;
    theme?: ITheme;
}

// @public (undocumented)
export interface IColorPickerState {
    color: IColor;
    editingColor?: {
        component: ColorComponent;
        value: string;
    };
}

// @public (undocumented)
export interface IColorPickerStrings {
    alpha?: string;
    alphaAriaLabel?: string;
    blue?: string;
    green?: string;
    hex?: string;
    // @deprecated
    hue?: string;
    hueAriaLabel?: string;
    red?: string;
    rootAriaLabelFormat?: string;
    svAriaDescription?: string;
    svAriaLabel?: string;
    svAriaValueFormat?: string;
    transparency?: string;
    transparencyAriaLabel?: string;
}

// @public (undocumented)
export type IColorPickerStyleProps = Required<Pick<IColorPickerProps, 'theme'>> & Pick<IColorPickerProps, 'className' | 'alphaType'>;

// @public (undocumented)
export interface IColorPickerStyles {
    colorRectangle?: IStyle;
    colorSquare?: IStyle;
    flexContainer?: IStyle;
    flexPreviewBox?: IStyle;
    flexSlider?: IStyle;
    input?: IStyle;
    panel?: IStyle;
    root?: IStyle;
    table?: IStyle;
    tableAlphaCell?: IStyle;
    tableHeader?: IStyle;
    tableHexCell?: IStyle;
}

// @public (undocumented)
export interface IColorRectangle {
    color: IColor;
}

// @public (undocumented)
export interface IColorRectangleProps {
    ariaDescription?: string;
    ariaLabel?: string;
    ariaValueFormat?: string;
    className?: string;
    color: IColor;
    componentRef?: IRefObject<IColorRectangle>;
    minSize?: number;
    onChange?: (ev: React.MouseEvent | React.KeyboardEvent, color: IColor) => void;
    styles?: IStyleFunctionOrObject<IColorRectangleStyleProps, IColorRectangleStyles>;
    theme?: ITheme;
}

// @public (undocumented)
export interface IColorRectangleStyleProps {
    className?: string;
    minSize?: number;
    theme: ITheme;
}

// @public (undocumented)
export interface IColorRectangleStyles {
    dark?: IStyle;
    description?: IStyle;
    light?: IStyle;
    root?: IStyle;
    thumb?: IStyle;
}

// @public (undocumented)
export interface IColorSlider {
    value: number;
}

// @public (undocumented)
export interface IColorSliderProps {
    ariaLabel?: string;
    className?: string;
    componentRef?: IRefObject<IColorSlider>;
    // @deprecated
    isAlpha?: boolean;
    // @deprecated
    maxValue?: number;
    // @deprecated
    minValue?: number;
    onChange?: (event: React.MouseEvent | React.KeyboardEvent, newValue?: number) => void;
    overlayColor?: string;
    // @deprecated
    overlayStyle?: React.CSSProperties;
    styles?: IStyleFunctionOrObject<IColorSliderStyleProps, IColorSliderStyles>;
    theme?: ITheme;
    // @deprecated
    thumbColor?: string;
    type?: 'hue' | 'alpha' | 'transparency';
    value?: number;
}

// @public (undocumented)
export type IColorSliderStyleProps = Required<Pick<IColorSliderProps, 'theme'>> & Pick<IColorSliderProps, 'className' | 'type'> & {
    isAlpha?: boolean;
};

// @public (undocumented)
export interface IColorSliderStyles {
    root?: IStyle;
    sliderOverlay?: IStyle;
    sliderThumb?: IStyle;
}

// @public (undocumented)
export interface ICommandBar {
    focus(): void;
    remeasure(): void;
}

// @public (undocumented)
export interface ICommandBarData {
    cacheKey: string;
    farItems: ICommandBarItemProps[] | undefined;
    minimumOverflowItems: number;
    overflowItems: ICommandBarItemProps[];
    primaryItems: ICommandBarItemProps[];
}

// @public
export interface ICommandBarItemProps extends IContextualMenuItem {
    buttonStyles?: IButtonStyles;
    cacheKey?: string;
    commandBarButtonAs?: IComponentAs<ICommandBarItemProps>;
    iconOnly?: boolean;
    renderedInOverflow?: boolean;
    tooltipHostProps?: ITooltipHostProps;
}

// @public (undocumented)
export interface ICommandBarProps extends React.HTMLAttributes<HTMLDivElement> {
    ariaLabel?: string;
    buttonAs?: IComponentAs<IButtonProps>;
    className?: string;
    componentRef?: IRefObject<ICommandBar>;
    dataDidRender?: (renderedData: any) => void;
    farItems?: ICommandBarItemProps[];
    items: ICommandBarItemProps[];
    onDataGrown?: (movedItem: ICommandBarItemProps) => void;
    onDataReduced?: (movedItem: ICommandBarItemProps) => void;
    onGrowData?: (data: ICommandBarData) => ICommandBarData | undefined;
    onReduceData?: (data: ICommandBarData) => ICommandBarData | undefined;
    overflowButtonAs?: IComponentAs<IButtonProps>;
    overflowButtonProps?: IButtonProps;
    overflowItems?: ICommandBarItemProps[];
    shiftOnReduce?: boolean;
    styles?: IStyleFunctionOrObject<ICommandBarStyleProps, ICommandBarStyles>;
    theme?: ITheme;
}

// @public (undocumented)
export interface ICommandBarStyleProps {
    // (undocumented)
    className?: string;
    // (undocumented)
    theme: ITheme;
}

// @public (undocumented)
export interface ICommandBarStyles {
    // (undocumented)
    primarySet?: IStyle;
    // (undocumented)
    root?: IStyle;
    // (undocumented)
    secondarySet?: IStyle;
}

// @public
export const Icon: React.FunctionComponent<IIconProps>;

// @public (undocumented)
export class IconBase extends React.Component<IIconProps, IIconState> {
    constructor(props: IIconProps);
    // (undocumented)
    render(): JSX.Element;
}

// @public (undocumented)
export class IconButton extends React.Component<IButtonProps, {}> {
    // (undocumented)
    render(): JSX.Element;
}

// @public (undocumented)
export interface IContextualMenu {
}

// @public (undocumented)
export interface IContextualMenuItem {
    [propertyName: string]: any;
    ariaLabel?: string;
    canCheck?: boolean;
    checked?: boolean;
    className?: string;
    componentRef?: IRefObject<IContextualMenuRenderItem>;
    customOnRenderListLength?: number;
    data?: any;
    disabled?: boolean;
    // Warning: (ae-forgotten-export) The symbol "IMenuItemClassNames" needs to be exported by the entry point index.d.ts
    //
    // @deprecated
    getItemClassNames?: (theme: ITheme, disabled: boolean, expanded: boolean, checked: boolean, isAnchorLink: boolean, knownIcon: boolean, itemClassName?: string, dividerClassName?: string, iconClassName?: string, subMenuClassName?: string, primaryDisabled?: boolean) => IMenuItemClassNames;
    getSplitButtonVerticalDividerClassNames?: (theme: ITheme) => IVerticalDividerClassNames;
    href?: string;
    iconProps?: IIconProps;
    // @deprecated
    inactive?: boolean;
    itemProps?: Partial<IContextualMenuItemProps>;
    // (undocumented)
    itemType?: ContextualMenuItemType;
    key: string;
    keytipProps?: IKeytipProps;
    // @deprecated
    name?: string;
    onClick?: (ev?: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>, item?: IContextualMenuItem) => boolean | void;
    onMouseDown?: (item: IContextualMenuItem, event: React.MouseEvent<HTMLElement>) => void;
    onRender?: (item: any, dismissMenu: (ev?: any, dismissAll?: boolean) => void) => React.ReactNode;
    onRenderContent?: (props: IContextualMenuItemProps, defaultRenders: IContextualMenuItemRenderFunctions) => React.ReactNode;
    onRenderIcon?: IRenderFunction<IContextualMenuItemProps>;
    primaryDisabled?: boolean;
    rel?: string;
    role?: string;
    secondaryText?: string;
    sectionProps?: IContextualMenuSection;
    // @deprecated (undocumented)
    shortCut?: string;
    split?: boolean;
    // @deprecated
    style?: React.CSSProperties;
    submenuIconProps?: IIconProps;
    subMenuProps?: IContextualMenuProps;
    target?: string;
    text?: string;
    title?: string;
}

// @public (undocumented)
export interface IContextualMenuItemProps extends React.HTMLAttributes<IContextualMenuItemProps> {
    className?: string;
    classNames: IMenuItemClassNames;
    componentRef?: IRefObject<IContextualMenuRenderItem>;
    dismissMenu?: (ev?: any, dismissAll?: boolean) => void;
    dismissSubMenu?: () => void;
    getSubmenuTarget?: () => HTMLElement | undefined;
    hasIcons: boolean | undefined;
    index: number;
    item: IContextualMenuItem;
    onCheckmarkClick?: (item: IContextualMenuItem, ev: React.MouseEvent<HTMLElement>) => void;
    openSubMenu?: (item: any, target: HTMLElement) => void;
    styles?: IStyleFunctionOrObject<IContextualMenuItemStyleProps, IContextualMenuItemStyles>;
    theme?: ITheme;
}

// @public (undocumented)
export interface IContextualMenuItemRenderFunctions {
    renderCheckMarkIcon: (props: IContextualMenuItemProps, customClassNames?: string[]) => React.ReactNode;
    renderItemIcon: (props: IContextualMenuItemProps, customClassNames?: string[]) => React.ReactNode;
    renderItemName: (props: IContextualMenuItemProps, customClassNames?: string[]) => React.ReactNode;
    renderSecondaryText: (props: IContextualMenuItemProps, customClassNames?: string[]) => React.ReactNode;
    renderSubMenuIcon: (props: IContextualMenuItemProps, customClassNames?: string[]) => React.ReactNode;
}

// @public (undocumented)
export interface IContextualMenuItemRenderProps extends IContextualMenuItem {
    // (undocumented)
    focusableElementIndex: number;
    // (undocumented)
    hasCheckmarks: boolean;
    // (undocumented)
    hasIcons: boolean;
    // (undocumented)
    index: number;
    // (undocumented)
    totalItemCount: number;
}

// @public (undocumented)
export interface IContextualMenuItemStyleProps {
    checked: boolean;
    className?: string;
    disabled: boolean;
    dividerClassName?: string;
    expanded: boolean;
    iconClassName?: string;
    isAnchorLink: boolean;
    itemClassName?: string;
    knownIcon: boolean;
    primaryDisabled?: boolean;
    subMenuClassName?: string;
    theme: ITheme;
}

// @public (undocumented)
export interface IContextualMenuItemStyles extends IButtonStyles {
    anchorLink: IStyle;
    checkmarkIcon: IStyle;
    divider: IStyle;
    icon: IStyle;
    iconColor: IStyle;
    item: IStyle;
    label: IStyle;
    linkContent: IStyle;
    linkContentMenu: IStyle;
    root: IStyle;
    secondaryText: IStyle;
    splitContainer: IStyle;
    splitMenu: IStyle;
    splitPrimary: IStyle;
    subMenuIcon: IStyle;
}

// @public (undocumented)
export interface IContextualMenuListProps {
    // (undocumented)
    defaultMenuItemRenderer: (item: IContextualMenuItemRenderProps) => React.ReactNode;
    // (undocumented)
    hasCheckmarks: boolean;
    // (undocumented)
    hasIcons: boolean;
    // (undocumented)
    items: IContextualMenuItem[];
    // (undocumented)
    role?: string;
    // (undocumented)
    totalItemCount: number;
}

// Warning: (ae-forgotten-export) The symbol "IWithResponsiveModeState" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export interface IContextualMenuProps extends IBaseProps<IContextualMenu>, IWithResponsiveModeState {
    alignTargetEdge?: boolean;
    ariaLabel?: string;
    beakWidth?: number;
    bounds?: IRectangle | ((target?: Target, targetWindow?: Window) => IRectangle | undefined);
    calloutProps?: ICalloutProps;
    className?: string;
    componentRef?: IRefObject<IContextualMenu>;
    contextualMenuItemAs?: React.ComponentClass<IContextualMenuItemProps> | React.FunctionComponent<IContextualMenuItemProps>;
    coverTarget?: boolean;
    delayUpdateFocusOnHover?: boolean;
    directionalHint?: DirectionalHint;
    directionalHintFixed?: boolean;
    directionalHintForRTL?: DirectionalHint;
    doNotLayer?: boolean;
    focusZoneProps?: IFocusZoneProps;
    gapSpace?: number;
    // Warning: (ae-forgotten-export) The symbol "IContextualMenuClassNames" needs to be exported by the entry point index.d.ts
    //
    // @deprecated
    getMenuClassNames?: (theme: ITheme, className?: string) => IContextualMenuClassNames;
    hidden?: boolean;
    id?: string;
    isBeakVisible?: boolean;
    isSubMenu?: boolean;
    items: IContextualMenuItem[];
    labelElementId?: string;
    onDismiss?: (ev?: React.MouseEvent | React.KeyboardEvent, dismissAll?: boolean) => void;
    onItemClick?: (ev?: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>, item?: IContextualMenuItem) => boolean | void;
    onMenuDismissed?: (contextualMenu?: IContextualMenuProps) => void;
    onMenuOpened?: (contextualMenu?: IContextualMenuProps) => void;
    onRenderMenuList?: IRenderFunction<IContextualMenuListProps>;
    onRenderSubMenu?: IRenderFunction<IContextualMenuProps>;
    onRestoreFocus?: (options: {
        originalElement?: HTMLElement | Window;
        containsFocus: boolean;
        documentContainsFocus: boolean;
    }) => void;
    shouldFocusOnContainer?: boolean;
    shouldFocusOnMount?: boolean;
    shouldUpdateWhenHidden?: boolean;
    styles?: IStyleFunctionOrObject<IContextualMenuStyleProps, IContextualMenuStyles>;
    subMenuHoverDelay?: number;
    target?: Target;
    theme?: ITheme;
    title?: string;
    useTargetAsMinWidth?: boolean;
    useTargetWidth?: boolean;
}

// @public (undocumented)
export interface IContextualMenuRenderItem {
    dismissMenu: (dismissAll?: boolean) => void;
    dismissSubMenu: () => void;
    openSubMenu: () => void;
}

// @public (undocumented)
export interface IContextualMenuSection extends React.ClassAttributes<any> {
    bottomDivider?: boolean;
    items: IContextualMenuItem[];
    title?: string;
    topDivider?: boolean;
}

// @public (undocumented)
export interface IContextualMenuState {
    // (undocumented)
    contextualMenuItems?: IContextualMenuItem[];
    // (undocumented)
    contextualMenuTarget?: Element;
    // (undocumented)
    dismissedMenuItemKey?: string;
    expandedByMouseClick?: boolean;
    // (undocumented)
    expandedMenuItemKey?: string;
    // (undocumented)
    positions?: any;
    // (undocumented)
    slideDirectionalClassName?: string;
    // (undocumented)
    submenuDirection?: DirectionalHint;
    // (undocumented)
    subMenuId?: string;
    // (undocumented)
    submenuTarget?: Element;
}

// @public (undocumented)
export interface IContextualMenuStyleProps {
    // (undocumented)
    className?: string;
    // (undocumented)
    theme: ITheme;
}

// @public (undocumented)
export interface IContextualMenuStyles {
    container: IStyle;
    header: IStyle;
    list: IStyle;
    root: IStyle;
    subComponentStyles: IContextualMenuSubComponentStyles;
    title: IStyle;
}

// @public (undocumented)
export interface IContextualMenuSubComponentStyles {
    callout: IStyleFunctionOrObject<ICalloutContentStyleProps, any>;
    menuItem: IStyleFunctionOrObject<IContextualMenuItemStyleProps, any>;
}

// @public @deprecated (undocumented)
export enum IconType {
    // @deprecated
    Default = 100000,
    // @deprecated
    default = 0,
    // @deprecated
    Image = 100001,
    // @deprecated
    image = 1
}

// @public (undocumented)
export interface IDatePicker {
    focus(): void;
    reset(): void;
}

// @public (undocumented)
export interface IDatePickerProps extends IBaseProps<IDatePicker>, React.HTMLAttributes<HTMLElement> {
    allFocusable?: boolean;
    allowTextInput?: boolean;
    ariaLabel?: string;
    borderless?: boolean;
    calendarAs?: IComponentAs<ICalendarProps>;
    calendarProps?: ICalendarProps;
    calloutProps?: ICalloutProps;
    className?: string;
    componentRef?: IRefObject<IDatePicker>;
    dateTimeFormatter?: ICalendarFormatDateCallbacks;
    disableAutoFocus?: boolean;
    disabled?: boolean;
    firstDayOfWeek?: DayOfWeek;
    firstWeekOfYear?: FirstWeekOfYear;
    formatDate?: (date?: Date) => string;
    highlightCurrentMonth?: boolean;
    highlightSelectedMonth?: boolean;
    initialPickerDate?: Date;
    isMonthPickerVisible?: boolean;
    isRequired?: boolean;
    label?: string;
    maxDate?: Date;
    minDate?: Date;
    onAfterMenuDismiss?: () => void;
    onSelectDate?: (date: Date | null | undefined) => void;
    parseDateFromString?: (dateStr: string) => Date | null;
    pickerAriaLabel?: string;
    placeholder?: string;
    showCloseButton?: boolean;
    showGoToToday?: boolean;
    showMonthPickerAsOverlay?: boolean;
    showWeekNumbers?: boolean;
    strings?: IDatePickerStrings;
    styles?: IStyleFunctionOrObject<IDatePickerStyleProps, IDatePickerStyles>;
    tabIndex?: number;
    textField?: ITextFieldProps;
    theme?: ITheme;
    today?: Date;
    underlined?: boolean;
    value?: Date;
}

// @public (undocumented)
export interface IDatePickerState {
    // (undocumented)
    errorMessage?: string;
    // (undocumented)
    formattedDate?: string;
    // (undocumented)
    isDatePickerShown?: boolean;
    // (undocumented)
    selectedDate?: Date;
}

// @public (undocumented)
export interface IDatePickerStrings extends ICalendarStrings {
    invalidInputErrorMessage?: string;
    isOutOfBoundsErrorMessage?: string;
    isRequiredErrorMessage?: string;
}

// @public (undocumented)
export interface IDatePickerStyleProps {
    className?: string;
    // (undocumented)
    disabled?: boolean;
    // (undocumented)
    isDatePickerShown?: boolean;
    // (undocumented)
    label?: boolean;
    theme: ITheme;
}

// @public (undocumented)
export interface IDatePickerStyles {
    // (undocumented)
    callout: IStyle;
    // (undocumented)
    icon: IStyle;
    root: IStyle;
    // (undocumented)
    textField: IStyle;
    // (undocumented)
    wrapper?: IStyle;
}

// @public (undocumented)
export interface IDialog {
}

// @public (undocumented)
export interface IDialogContent {
}

// @public (undocumented)
export interface IDialogContentProps extends React.ClassAttributes<DialogContentBase> {
    className?: string;
    closeButtonAriaLabel?: string;
    componentRef?: IRefObject<IDialogContent>;
    draggableHeaderClassName?: string;
    isMultiline?: boolean;
    onDismiss?: (ev?: React.MouseEvent<HTMLButtonElement>) => any;
    responsiveMode?: ResponsiveMode;
    showCloseButton?: boolean;
    styles?: IStyleFunctionOrObject<IDialogContentStyleProps, IDialogContentStyles>;
    subText?: string;
    subTextId?: string;
    theme?: ITheme;
    title?: string | JSX.Element;
    // @deprecated
    titleId?: string;
    titleProps?: React.HTMLAttributes<HTMLDivElement>;
    topButtonsProps?: IButtonProps[];
    type?: DialogType;
}

// @public (undocumented)
export interface IDialogContentStyleProps {
    className?: string;
    draggableHeaderClassName?: string;
    // (undocumented)
    hidden?: boolean;
    // (undocumented)
    isClose?: boolean;
    // (undocumented)
    isLargeHeader?: boolean;
    isMultiline?: boolean;
    theme: ITheme;
}

// @public (undocumented)
export interface IDialogContentStyles {
    // (undocumented)
    button: IStyle;
    content: IStyle;
    // (undocumented)
    header: IStyle;
    // (undocumented)
    inner: IStyle;
    // (undocumented)
    innerContent: IStyle;
    // (undocumented)
    subText: IStyle;
    // (undocumented)
    title: IStyle;
    // (undocumented)
    topButton: IStyle;
}

// @public (undocumented)
export interface IDialogFooter {
}

// @public (undocumented)
export interface IDialogFooterProps extends React.Props<DialogFooterBase> {
    className?: string;
    componentRef?: IRefObject<IDialogFooter>;
    styles?: IStyleFunctionOrObject<IDialogFooterStyleProps, IDialogFooterStyles>;
    theme?: ITheme;
}

// @public (undocumented)
export interface IDialogFooterStyleProps {
    className?: string;
    theme: ITheme;
}

// @public (undocumented)
export interface IDialogFooterStyles {
    // (undocumented)
    action: IStyle;
    actions: IStyle;
    // (undocumented)
    actionsRight: IStyle;
}

// @public (undocumented)
export interface IDialogProps extends React.ClassAttributes<DialogBase>, IWithResponsiveModeState, IAccessiblePopupProps {
    // @deprecated
    ariaDescribedById?: string;
    // @deprecated
    ariaLabelledById?: string;
    // @deprecated
    className?: string;
    // @deprecated
    componentRef?: IRefObject<IDialog>;
    // @deprecated
    containerClassName?: string;
    // @deprecated
    contentClassName?: string;
    dialogContentProps?: IDialogContentProps;
    hidden?: boolean;
    // @deprecated
    isBlocking?: boolean;
    // @deprecated
    isDarkOverlay?: boolean;
    // @deprecated
    isOpen?: boolean;
    maxWidth?: ICSSRule | ICSSPixelUnitRule;
    minWidth?: ICSSRule | ICSSPixelUnitRule;
    modalProps?: IModalProps;
    onDismiss?: (ev?: React.MouseEvent<HTMLButtonElement>) => any;
    // @deprecated
    onDismissed?: () => any;
    // @deprecated
    onLayerDidMount?: () => void;
    // @deprecated
    onLayerMounted?: () => void;
    styles?: IStyleFunctionOrObject<IDialogStyleProps, IDialogStyles>;
    // @deprecated
    subText?: string;
    theme?: ITheme;
    // @deprecated
    title?: string | JSX.Element;
    // @deprecated
    topButtonsProps?: IButtonProps[];
    // @deprecated
    type?: DialogType;
}

// @public (undocumented)
export interface IDialogState {
    // (undocumented)
    hasBeenOpened?: boolean;
    // (undocumented)
    id?: string;
    // (undocumented)
    isInKeyboardMoveMode?: boolean;
    // (undocumented)
    isModalMenuOpen?: boolean;
    // (undocumented)
    isOpen?: boolean;
    // (undocumented)
    isVisible?: boolean;
    // (undocumented)
    isVisibleClose?: boolean;
    // (undocumented)
    modalRectangleTop?: number;
    // (undocumented)
    x: number;
    // (undocumented)
    y: number;
}

// @public (undocumented)
export interface IDialogStyleProps {
    className?: string;
    // @deprecated
    containerClassName?: string;
    // @deprecated
    contentClassName?: string;
    dialogDefaultMaxWidth?: string | ICSSRule | ICSSPixelUnitRule;
    dialogDefaultMinWidth?: string | ICSSRule | ICSSPixelUnitRule;
    hidden?: boolean;
    theme: ITheme;
}

// @public (undocumented)
export interface IDialogStyles {
    // (undocumented)
    main: IStyle;
    root: IStyle;
}

// @public
export interface IDragDropContext {
    data: any;
    index: number;
    isGroup?: boolean;
}

// @public (undocumented)
export interface IDragDropEvent {
    isHandled?: boolean;
}

// @public
export interface IDragDropEvents {
    canDrag?: (item?: any) => boolean;
    canDragGroups?: boolean;
    canDrop?: (dropContext?: IDragDropContext, dragContext?: IDragDropContext) => boolean;
    onDragEnd?: (item?: any, event?: DragEvent) => void;
    onDragEnter?: (item?: any, event?: DragEvent) => string;
    onDragLeave?: (item?: any, event?: DragEvent) => void;
    onDragOver?: (item?: any, event?: DragEvent) => void;
    onDragStart?: (item?: any, itemIndex?: number, selectedItems?: any[], event?: MouseEvent) => void;
    onDrop?: (item?: any, event?: DragEvent) => void;
}

// @public
export interface IDragDropHelper {
    dispose: () => void;
    subscribe: (root: HTMLElement, events: EventGroup, options: IDragDropOptions) => {
        key: string;
        dispose: () => void;
    };
    unsubscribe: (root: HTMLElement, key: string) => void;
}

// @public (undocumented)
export interface IDragDropHelperParams {
    // (undocumented)
    minimumPixelsForDrag?: number;
    // (undocumented)
    selection: ISelection;
}

// @public
export interface IDragDropOptions {
    canDrag?: (item?: any) => boolean;
    canDrop?: (dropContext?: IDragDropContext, dragContext?: IDragDropContext) => boolean;
    context: IDragDropContext;
    eventMap?: {
        eventName: string;
        callback: (context: IDragDropContext, event?: any) => void;
    }[];
    key?: string;
    onDragEnd?: (item?: any, event?: DragEvent) => void;
    onDragOver?: (item?: any, event?: DragEvent) => void;
    onDragStart?: (item?: any, itemIndex?: number, selectedItems?: any[], event?: MouseEvent) => void;
    onDrop?: (item?: any, event?: DragEvent) => void;
    selectionIndex: number;
    updateDropState: (isDropping: boolean, event: DragEvent) => void;
}

// @public (undocumented)
export interface IDragDropTarget {
    // (undocumented)
    key: string;
    // (undocumented)
    options: IDragDropOptions;
    // (undocumented)
    root: HTMLElement;
}

// @public (undocumented)
export interface IDragOptions {
    closeMenuItemText: string;
    dragHandleSelector?: string;
    keepInBounds?: boolean;
    keyboardMoveIconProps?: IIconProps;
    menu: React.FunctionComponent<IContextualMenuProps>;
    moveMenuItemText: string;
}

// @public (undocumented)
export interface IEditingSelectedPeopleItemProps extends ISelectedPeopleItemProps {
    // (undocumented)
    floatingPickerProps?: IBaseFloatingPickerProps<IPersonaProps>;
    // (undocumented)
    getEditingItemText?: (item: IExtendedPersonaProps) => string;
    // (undocumented)
    onEditingComplete: (oldItem: any, newItem: any) => void;
    // (undocumented)
    onRenderFloatingPicker?: React.ComponentType<IBaseFloatingPickerProps<IPersonaProps>>;
}

// @public (undocumented)
export interface IEditingSelectedPeopleItemStyles {
    // (undocumented)
    input: IStyle;
    // (undocumented)
    root: IStyle;
}

// @public (undocumented)
export interface IEditingSelectedPeopleItemStylesProps {
}

// @public
export interface IElementPosition {
    // (undocumented)
    alignmentEdge: RectangleEdge | undefined;
    // (undocumented)
    elementRectangle: Rectangle;
    // (undocumented)
    targetEdge: RectangleEdge;
}

// @public (undocumented)
export interface IElementPositionInfo extends IElementPosition {
    // (undocumented)
    targetRectangle: Rectangle;
}

// @public
export interface IEntityRect {
    // (undocumented)
    height?: number;
    // (undocumented)
    width?: number;
}

// @public (undocumented)
export interface IExpandingCard {
}

// Warning: (ae-forgotten-export) The symbol "IBaseCardProps" needs to be exported by the entry point index.d.ts
//
// @public
export interface IExpandingCardProps extends IBaseCardProps<IExpandingCard, IExpandingCardStyles, IExpandingCardStyleProps> {
    compactCardHeight?: number;
    expandedCardHeight?: number;
    mode?: ExpandingCardMode;
    onRenderCompactCard?: IRenderFunction<any>;
    onRenderExpandedCard?: IRenderFunction<any>;
}

// @public (undocumented)
export interface IExpandingCardState {
    // (undocumented)
    firstFrameRendered: boolean;
    // (undocumented)
    needsScroll: boolean;
}

// Warning: (ae-forgotten-export) The symbol "IBaseCardStyleProps" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export interface IExpandingCardStyleProps extends IBaseCardStyleProps {
    compactCardHeight?: number;
    expandedCardFirstFrameRendered?: boolean;
    expandedCardHeight?: number;
    needsScroll?: boolean;
}

// Warning: (ae-forgotten-export) The symbol "IBaseCardStyles" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export interface IExpandingCardStyles extends IBaseCardStyles {
    compactCard?: IStyle;
    expandedCard?: IStyle;
    expandedCardScroll?: IStyle;
}

// @public (undocumented)
export interface IExtendedPeoplePickerProps extends IBaseExtendedPickerProps<IPersonaProps> {
}

// @public (undocumented)
export interface IExtendedPersonaProps extends IPersonaProps {
    // (undocumented)
    blockRecipientRemoval?: boolean;
    // (undocumented)
    canExpand?: boolean;
    // (undocumented)
    isEditing?: boolean;
    // (undocumented)
    isValid: boolean;
    // (undocumented)
    key?: React.Key;
    // (undocumented)
    shouldBlockSelection?: boolean;
}

// @public (undocumented)
export interface IFabricProps extends React.HTMLAttributes<HTMLDivElement>, React.RefAttributes<HTMLDivElement> {
    applyTheme?: boolean;
    applyThemeToBody?: boolean;
    as?: React.ElementType;
    // (undocumented)
    componentRef?: IRefObject<{}>;
    dir?: 'rtl' | 'ltr' | 'auto';
    styles?: IStyleFunctionOrObject<IFabricStyleProps, IFabricStyles>;
    theme?: ITheme;
}

// @public (undocumented)
export interface IFabricStyleProps extends IFabricProps {
    // (undocumented)
    theme: ITheme;
}

// @public (undocumented)
export interface IFabricStyles {
    // (undocumented)
    bodyThemed: IStyle;
    // (undocumented)
    root: IStyle;
}

// @public (undocumented)
export interface IFacepile {
}

// @public (undocumented)
export interface IFacepilePersona extends React.ButtonHTMLAttributes<HTMLButtonElement | HTMLDivElement> {
    allowPhoneInitials?: boolean;
    data?: any;
    imageInitials?: string;
    imageUrl?: string;
    initialsColor?: PersonaInitialsColor;
    keytipProps?: IKeytipProps;
    onClick?: (ev?: React.MouseEvent<HTMLElement>, persona?: IFacepilePersona) => void;
    onMouseMove?: (ev?: React.MouseEvent<HTMLElement>, persona?: IFacepilePersona) => void;
    onMouseOut?: (ev?: React.MouseEvent<HTMLElement>, persona?: IFacepilePersona) => void;
    personaName?: string;
}

// @public (undocumented)
export interface IFacepileProps extends React.ClassAttributes<FacepileBase> {
    addButtonProps?: IButtonProps;
    ariaDescription?: string;
    ariaLabel?: string;
    // @deprecated
    chevronButtonProps?: IButtonProps;
    className?: string;
    componentRef?: IRefObject<IFacepile>;
    getPersonaProps?: (persona: IFacepilePersona) => IPersonaSharedProps;
    maxDisplayablePersonas?: number;
    onRenderPersona?: IRenderFunction<IFacepilePersona>;
    onRenderPersonaCoin?: IRenderFunction<IFacepilePersona>;
    overflowButtonProps?: IButtonProps;
    overflowButtonType?: OverflowButtonType;
    overflowPersonas?: IFacepilePersona[];
    personas: IFacepilePersona[];
    personaSize?: PersonaSize;
    showAddButton?: boolean;
    styles?: IStyleFunctionOrObject<IFacepileStyleProps, IFacepileStyles>;
    theme?: ITheme;
}

// @public (undocumented)
export interface IFacepileStyleProps {
    className?: string;
    spacingAroundItemButton?: number;
    theme: ITheme;
}

// @public (undocumented)
export interface IFacepileStyles {
    // (undocumented)
    addButton: IStyle;
    // (undocumented)
    descriptiveOverflowButton: IStyle;
    // (undocumented)
    itemButton: IStyle;
    // (undocumented)
    itemContainer: IStyle;
    // (undocumented)
    member: IStyle;
    // (undocumented)
    members: IStyle;
    // (undocumented)
    overflowButton: IStyle;
    // (undocumented)
    overflowInitialsIcon: IStyle;
    root: IStyle;
    // (undocumented)
    screenReaderOnly: IStyle;
}

// @public (undocumented)
export interface IFocusTrapCalloutProps extends ICalloutProps {
    focusTrapProps?: IFocusTrapZoneProps;
}

// @public (undocumented)
export interface IFocusTrapZone {
    focus: () => void;
}

// @public (undocumented)
export interface IFocusTrapZoneProps extends React.HTMLAttributes<HTMLDivElement> {
    ariaLabelledBy?: string;
    componentRef?: IRefObject<IFocusTrapZone>;
    disabled?: boolean;
    disableFirstFocus?: boolean;
    elementToFocusOnDismiss?: HTMLElement;
    enableAriaHiddenSiblings?: boolean;
    firstFocusableSelector?: string | (() => string);
    focusPreviouslyFocusedInnerElement?: boolean;
    forceFocusInsideTrap?: boolean;
    ignoreExternalFocusing?: boolean;
    isClickableOutsideFocusTrap?: boolean;
}

// @public
export interface IFontIconProps extends React.HTMLAttributes<HTMLElement> {
    className?: string;
    iconName?: string;
}

// @public
export interface IGap extends IShimmerElement {
    height?: number;
    width?: number | string;
}

// @public (undocumented)
export interface IGenericItem {
    // (undocumented)
    imageInitials: string;
    // (undocumented)
    primaryText: string;
    // (undocumented)
    ValidationState: ValidationState;
}

// @public (undocumented)
export interface IHoverCard {
    dismiss: (withTimeOut?: boolean) => void;
}

// @public
export interface IHoverCardProps extends React.HTMLAttributes<HTMLDivElement> {
    cardDismissDelay?: number;
    cardOpenDelay?: number;
    className?: string;
    componentRef?: IRefObject<IHoverCard>;
    eventListenerTarget?: HTMLElement | string | null;
    expandedCardOpenDelay?: number;
    expandingCardProps?: IExpandingCardProps;
    instantOpenOnClick?: boolean;
    onCardExpand?: () => void;
    onCardHide?: () => void;
    onCardVisible?: () => void;
    openHotKey?: KeyCodes;
    plainCardProps?: IPlainCardProps;
    setAriaDescribedBy?: boolean;
    setInitialFocus?: boolean;
    shouldBlockHoverCard?: () => void;
    sticky?: boolean;
    styles?: IStyleFunctionOrObject<IHoverCardStyleProps, IHoverCardStyles>;
    target?: HTMLElement | string | null;
    theme?: ITheme;
    trapFocus?: boolean;
    type?: HoverCardType;
}

// @public (undocumented)
export interface IHoverCardState {
    // (undocumented)
    isHoverCardVisible?: boolean;
    // (undocumented)
    mode?: ExpandingCardMode;
    // (undocumented)
    openMode?: OpenCardMode;
}

// @public (undocumented)
export interface IHoverCardStyleProps {
    className?: string;
    theme: ITheme;
}

// @public (undocumented)
export interface IHoverCardStyles {
    host?: IStyle;
}

// @public (undocumented)
export interface IHSL {
    h: number;
    l: number;
    s: number;
}

// @public (undocumented)
export interface IHSV {
    h: number;
    s: number;
    v: number;
}

// @public (undocumented)
export interface IIconContent {
    // (undocumented)
    children?: string;
    // (undocumented)
    fontFamily?: string;
    // (undocumented)
    iconClassName?: string;
}

// @public (undocumented)
export interface IIconProps extends IBaseProps, React.HTMLAttributes<HTMLElement> {
    // @deprecated
    ariaLabel?: string;
    iconName?: string;
    // @deprecated
    iconType?: IconType;
    imageErrorAs?: React.ComponentType<IImageProps>;
    imageProps?: IImageProps;
    styles?: IStyleFunctionOrObject<IIconStyleProps, IIconStyles>;
    // (undocumented)
    theme?: ITheme;
}

// @public (undocumented)
export interface IIconState {
    // (undocumented)
    imageLoadError: boolean;
}

// @public (undocumented)
export interface IIconStyleProps {
    // (undocumented)
    className?: string;
    // (undocumented)
    iconClassName?: string;
    // (undocumented)
    isImage: boolean;
    // (undocumented)
    isPlaceholder: boolean;
    // (undocumented)
    styles?: Partial<IIconStyles>;
    // (undocumented)
    theme?: ITheme;
}

// @public (undocumented)
export interface IIconStyles {
    // @deprecated
    imageContainer?: IStyle;
    // (undocumented)
    root?: IStyle;
}

// @public (undocumented)
export interface IImage {
}

// @public
export interface IImageIconProps extends React.HTMLAttributes<HTMLElement> {
    className?: string;
    imageProps: IImageProps;
}

// @public (undocumented)
export interface IImageProps extends React.ImgHTMLAttributes<HTMLImageElement>, React.RefAttributes<HTMLImageElement> {
    className?: string;
    coverStyle?: ImageCoverStyle;
    // @deprecated
    errorSrc?: string;
    imageFit?: ImageFit;
    maximizeFrame?: boolean;
    onLoadingStateChange?: (loadState: ImageLoadState) => void;
    shouldFadeIn?: boolean;
    shouldStartVisible?: boolean;
    styles?: IStyleFunctionOrObject<IImageStyleProps, IImageStyles>;
    theme?: ITheme;
}

// @public (undocumented)
export interface IImageState {
    // (undocumented)
    loadState?: ImageLoadState;
}

// @public (undocumented)
export interface IImageStyleProps {
    className?: string;
    height?: number | string;
    isCenter?: boolean;
    // (undocumented)
    isCenterContain?: boolean;
    // (undocumented)
    isCenterCover?: boolean;
    // (undocumented)
    isContain?: boolean;
    // (undocumented)
    isCover?: boolean;
    isError?: boolean;
    isLandscape?: boolean;
    isLoaded?: boolean;
    // (undocumented)
    isNone?: boolean;
    isNotImageFit?: boolean;
    maximizeFrame?: boolean;
    shouldFadeIn?: boolean;
    shouldStartVisible?: boolean;
    theme: ITheme;
    width?: number | string;
}

// @public (undocumented)
export interface IImageStyles {
    image: IStyle;
    root: IStyle;
}

// @public
export interface IInputProps extends React.InputHTMLAttributes<HTMLInputElement> {
    'aria-label'?: string;
    defaultVisibleValue?: string;
}

// @public (undocumented)
export interface IKeytipConfig {
    // (undocumented)
    keytips: IKeytipConfigItem[];
}

// @public (undocumented)
export interface IKeytipConfigItem {
    children?: IKeytipConfigItem[];
    content: string;
    id: string;
    optionalProps?: Partial<IKeytipProps>;
    sequence?: string;
}

// @public (undocumented)
export interface IKeytipConfigMap {
    // (undocumented)
    [id: string]: IKeytipProps;
}

// @public (undocumented)
export interface IKeytipDataProps {
    ariaDescribedBy?: string;
    disabled?: boolean;
    keytipProps?: IKeytipProps;
}

// @public (undocumented)
export interface IKeytipLayer {
}

// @public (undocumented)
export interface IKeytipLayerProps extends React.ClassAttributes<IKeytipLayer> {
    componentRef?: IRefObject<IKeytipLayer>;
    content: string;
    keytipExitSequences?: IKeytipTransitionKey[];
    keytipReturnSequences?: IKeytipTransitionKey[];
    keytipStartSequences?: IKeytipTransitionKey[];
    onEnterKeytipMode?: () => void;
    onExitKeytipMode?: (ev?: React.KeyboardEvent<HTMLElement> | React.MouseEvent<HTMLElement>) => void;
    styles?: IStyleFunctionOrObject<IKeytipLayerStyleProps, IKeytipLayerStyles>;
}

// @public (undocumented)
export interface IKeytipLayerState {
    // (undocumented)
    inKeytipMode: boolean;
    // (undocumented)
    keytips: IKeytipProps[];
    // (undocumented)
    visibleKeytips: IKeytipProps[];
}

// @public (undocumented)
export interface IKeytipLayerStyleProps {
}

// @public (undocumented)
export interface IKeytipLayerStyles {
    // (undocumented)
    innerContent: IStyle;
}

// @public (undocumented)
export interface IKeytipProps {
    calloutProps?: ICalloutProps;
    content: string;
    disabled?: boolean;
    hasDynamicChildren?: boolean;
    hasMenu?: boolean;
    keySequences: string[];
    offset?: Point;
    onExecute?: (executeTarget: HTMLElement | null, target: HTMLElement | null) => void;
    onReturn?: (executeTarget: HTMLElement | null, target: HTMLElement | null) => void;
    overflowSetSequence?: string[];
    styles?: IStyleFunctionOrObject<IKeytipStyleProps, IKeytipStyles>;
    theme?: ITheme;
    visible?: boolean;
}

// @public
export interface IKeytipStyleProps {
    disabled?: boolean;
    theme: ITheme;
    visible?: boolean;
}

// @public (undocumented)
export interface IKeytipStyles {
    container: IStyle;
    root: IStyle;
}

// @public (undocumented)
export interface IKeytipTransitionKey {
    // (undocumented)
    key: string;
    // (undocumented)
    modifierKeys?: KeytipTransitionModifier[];
}

// @public (undocumented)
export interface ILabel {
}

// @public (undocumented)
export interface ILabelProps extends React.LabelHTMLAttributes<HTMLLabelElement> {
    as?: IComponentAs<React.AllHTMLAttributes<HTMLElement>>;
    componentRef?: IRefObject<ILabel>;
    disabled?: boolean;
    required?: boolean;
    styles?: IStyleFunctionOrObject<ILabelStyleProps, ILabelStyles>;
    theme?: ITheme;
}

// @public (undocumented)
export interface ILabelStyleProps {
    // (undocumented)
    className?: string;
    // (undocumented)
    disabled?: boolean;
    // (undocumented)
    required?: boolean;
    // (undocumented)
    theme: ITheme;
}

// @public (undocumented)
export interface ILabelStyles {
    root: IStyle;
}

// @public (undocumented)
export interface ILayer {
}

// @public (undocumented)
export type ILayerBaseState = {
    hostId?: string;
    layerElement?: HTMLElement;
};

// @public (undocumented)
export interface ILayerProps extends React.HTMLAttributes<HTMLDivElement | LayerBase> {
    className?: string;
    componentRef?: IRefObject<ILayer>;
    eventBubblingEnabled?: boolean;
    hostId?: string;
    insertFirst?: boolean;
    onLayerDidMount?: () => void;
    // @deprecated
    onLayerMounted?: () => void;
    onLayerWillUnmount?: () => void;
    styles?: IStyleFunctionOrObject<ILayerStyleProps, ILayerStyles>;
    theme?: ITheme;
}

// @public (undocumented)
export interface ILayerStyleProps {
    className?: string;
    isNotHost?: boolean;
    theme: ITheme;
}

// @public (undocumented)
export interface ILayerStyles {
    content?: IStyle;
    root?: IStyle;
}

// @public
export interface ILine extends IShimmerElement {
    height?: number;
    width?: number | string;
}

// @public (undocumented)
export interface IList {
    forceUpdate: () => void;
    getStartItemIndexInView: () => number;
    getTotalListHeight?: () => number;
    scrollToIndex: (index: number, measureItem?: (itemIndex: number) => number, scrollToMode?: ScrollToMode) => void;
}

// @public
export interface IListOnRenderRootProps<T> {
    divProps: React.HTMLAttributes<HTMLDivElement>;
    pages: IPage<T>[];
    rootRef: React.Ref<HTMLDivElement>;
    surfaceElement: JSX.Element | null;
}

// @public
export interface IListOnRenderSurfaceProps<T> {
    divProps: React.HTMLAttributes<HTMLDivElement>;
    pageElements: JSX.Element[];
    pages: IPage<T>[];
    surfaceRef: React.Ref<HTMLDivElement>;
}

// @public (undocumented)
export interface IListProps<T = any> extends React.HTMLAttributes<List<T> | HTMLDivElement> {
    className?: string;
    componentRef?: IRefObject<IList>;
    getItemCountForPage?: (itemIndex?: number, visibleRect?: IRectangle) => number;
    getKey?: (item: T, index?: number) => string;
    getPageHeight?: (itemIndex?: number, visibleRect?: IRectangle, itemCount?: number) => number;
    getPageSpecification?: (itemIndex?: number, visibleRect?: IRectangle) => IPageSpecification;
    getPageStyle?: (page: IPage<T>) => any;
    ignoreScrollingState?: boolean;
    items?: T[];
    onPageAdded?: (page: IPage<T>) => void;
    onPageRemoved?: (page: IPage<T>) => void;
    onPagesUpdated?: (pages: IPage<T>[]) => void;
    onRenderCell?: (item?: T, index?: number, isScrolling?: boolean) => React.ReactNode;
    onRenderPage?: IRenderFunction<IPageProps<T>>;
    onRenderRoot?: IRenderFunction<IListOnRenderRootProps<T>>;
    onRenderSurface?: IRenderFunction<IListOnRenderSurfaceProps<T>>;
    onShouldVirtualize?: (props: IListProps<T>) => boolean;
    renderCount?: number;
    renderedWindowsAhead?: number;
    renderedWindowsBehind?: number;
    role?: string;
    startIndex?: number;
    usePageCache?: boolean;
    version?: {};
}

// @public (undocumented)
export interface IListState<T = any> {
    // (undocumented)
    getDerivedStateFromProps(nextProps: IListProps<T>, previousState: IListState<T>): IListState<T>;
    // (undocumented)
    isScrolling?: boolean;
    measureVersion?: number;
    // (undocumented)
    pages?: IPage<T>[];
}

// @public (undocumented)
export const Image: React.FunctionComponent<IImageProps>;

// @public (undocumented)
export const ImageBase: React.FunctionComponent<IImageProps>;

// @public
export enum ImageCoverStyle {
    landscape = 0,
    portrait = 1
}

// @public
export enum ImageFit {
    center = 0,
    centerContain = 5,
    centerCover = 4,
    contain = 1,
    cover = 2,
    none = 3
}

// @public
export const ImageIcon: React.FunctionComponent<IImageIconProps>;

// @public (undocumented)
export enum ImageLoadState {
    error = 2,
    // @deprecated
    errorLoaded = 3,
    loaded = 1,
    notLoaded = 0
}

// @public (undocumented)
export interface IMarqueeSelection {
}

// @public (undocumented)
export interface IMarqueeSelectionProps extends React.HTMLAttributes<HTMLDivElement> {
    className?: string;
    componentRef?: IRefObject<IMarqueeSelection>;
    isDraggingConstrainedToRoot?: boolean;
    isEnabled?: boolean;
    onShouldStartSelection?: (ev: MouseEvent) => boolean;
    rootProps?: React.HTMLAttributes<HTMLDivElement>;
    selection: ISelection;
    styles?: IStyleFunction<IMarqueeSelectionStyleProps, IMarqueeSelectionStyles>;
    theme?: ITheme;
}

// @public (undocumented)
export interface IMarqueeSelectionStyleProps {
    // (undocumented)
    className?: string;
    // (undocumented)
    theme: ITheme;
}

// @public (undocumented)
export interface IMarqueeSelectionStyles {
    // (undocumented)
    box?: IStyle;
    // (undocumented)
    boxFill?: IStyle;
    // (undocumented)
    dragMask?: IStyle;
    // (undocumented)
    root?: IStyle;
}

// @public (undocumented)
export interface IMaskedTextField extends ITextField {
    value: string | undefined;
}

// @public
export interface IMaskedTextFieldProps extends ITextFieldProps, React.RefAttributes<HTMLDivElement> {
    componentRef?: IRefObject<IMaskedTextField>;
    mask?: string;
    maskChar?: string;
    maskFormat?: {
        [key: string]: RegExp;
    };
}

// @public (undocumented)
export interface IMenuItemStyles extends IButtonStyles {
    anchorLink: IStyle;
    checkmarkIcon: IStyle;
    divider: IStyle;
    iconColor: IStyle;
    item: IStyle;
    linkContent: IStyle;
    subMenuIcon: IStyle;
}

// @public (undocumented)
export interface IMessageBar {
}

// @public (undocumented)
export interface IMessageBarProps extends React.HTMLAttributes<HTMLElement>, React.RefAttributes<HTMLDivElement> {
    actions?: JSX.Element;
    // @deprecated
    ariaLabel?: string;
    className?: string;
    componentRef?: IRefObject<IMessageBar>;
    dismissButtonAriaLabel?: string;
    dismissIconProps?: IIconProps;
    isMultiline?: boolean;
    messageBarIconProps?: IIconProps;
    messageBarType?: MessageBarType;
    onDismiss?: (ev?: React.MouseEvent<HTMLElement | BaseButton | Button>) => any;
    overflowButtonAriaLabel?: string;
    styles?: IStyleFunctionOrObject<IMessageBarStyleProps, IMessageBarStyles>;
    theme?: ITheme;
    truncated?: boolean;
}

// @public (undocumented)
export interface IMessageBarStyleProps {
    actions?: boolean;
    className?: string;
    expandSingleLine?: boolean;
    isMultiline?: boolean;
    messageBarType?: MessageBarType;
    onDismiss?: boolean;
    theme: ITheme;
    truncated?: boolean;
}

// @public (undocumented)
export interface IMessageBarStyles {
    actions?: IStyle;
    content?: IStyle;
    dismissal?: IStyle;
    dismissSingleLine?: IStyle;
    expand?: IStyle;
    expandSingleLine?: IStyle;
    icon?: IStyle;
    iconContainer?: IStyle;
    innerText?: IStyle;
    root?: IStyle;
    text?: IStyle;
}

// @public (undocumented)
export interface IModal {
    focus: () => void;
}

// @public (undocumented)
export interface IModalProps extends React.ClassAttributes<ModalBase>, IWithResponsiveModeState, IAccessiblePopupProps {
    allowTouchBodyScroll?: boolean;
    className?: string;
    componentRef?: IRefObject<IModal>;
    containerClassName?: string;
    dragOptions?: IDragOptions;
    enableAriaHiddenSiblings?: boolean;
    isBlocking?: boolean;
    isDarkOverlay?: boolean;
    isModeless?: boolean;
    isOpen?: boolean;
    layerProps?: ILayerProps;
    onDismiss?: (ev?: React.MouseEvent<HTMLButtonElement>) => any;
    onDismissed?: () => any;
    // @deprecated
    onLayerDidMount?: () => void;
    overlay?: IOverlayProps;
    scrollableContentClassName?: string;
    styles?: IStyleFunctionOrObject<IModalStyleProps, IModalStyles>;
    subtitleAriaId?: string;
    theme?: ITheme;
    titleAriaId?: string;
    topOffsetFixed?: boolean;
}

// @public (undocumented)
export type IModalStyleProps = Required<Pick<IModalProps, 'theme'>> & Pick<IModalProps, 'className' | 'containerClassName' | 'scrollableContentClassName' | 'topOffsetFixed' | 'isModeless'> & {
    isOpen?: boolean;
    isVisible?: boolean;
    hasBeenOpened?: boolean;
    modalRectangleTop?: number;
    layerClassName?: string;
    isDefaultDragHandle?: boolean;
};

// @public (undocumented)
export interface IModalStyles {
    // (undocumented)
    keyboardMoveIcon: IStyle;
    // (undocumented)
    keyboardMoveIconContainer: IStyle;
    // (undocumented)
    layer: IStyle;
    // (undocumented)
    main: IStyle;
    // (undocumented)
    root: IStyle;
    // (undocumented)
    scrollableContent: IStyle;
}

// @public (undocumented)
export interface INav {
    focus(forceIntoFirstElement?: boolean): boolean;
    selectedKey: string | undefined;
}

// @public (undocumented)
export interface INavButtonProps extends IButtonProps {
    link?: INavLink;
}

// @public (undocumented)
export interface INavLink {
    [propertyName: string]: any;
    ariaCurrent?: 'page' | 'step' | 'location' | 'date' | 'time' | 'true';
    ariaLabel?: string;
    automationId?: string;
    collapseAriaLabel?: string;
    disabled?: boolean;
    expandAriaLabel?: string;
    forceAnchor?: boolean;
    icon?: string;
    // @deprecated
    iconClassName?: string;
    iconProps?: IIconProps;
    isExpanded?: boolean;
    key?: string;
    links?: INavLink[];
    name: string;
    onClick?: (ev?: React.MouseEvent<HTMLElement>, item?: INavLink) => void;
    target?: string;
    title?: string;
    url: string;
}

// @public (undocumented)
export interface INavLinkGroup {
    automationId?: string;
    collapseAriaLabel?: string;
    collapseByDefault?: boolean;
    expandAriaLabel?: string;
    groupData?: any;
    links: INavLink[];
    name?: string;
    onHeaderClick?: (ev?: React.MouseEvent<HTMLElement>, isCollapsing?: boolean) => void;
}

// @public (undocumented)
export interface INavProps {
    ariaLabel?: string;
    className?: string;
    componentRef?: IRefObject<INav>;
    // @deprecated
    expandButtonAriaLabel?: string;
    groups: INavLinkGroup[] | null;
    initialSelectedKey?: string;
    isOnTop?: boolean;
    linkAs?: IComponentAs<INavButtonProps>;
    onLinkClick?: (ev?: React.MouseEvent<HTMLElement>, item?: INavLink) => void;
    onLinkExpandClick?: (ev?: React.MouseEvent<HTMLElement>, item?: INavLink) => void;
    onRenderGroupHeader?: IRenderFunction<IRenderGroupHeaderProps>;
    onRenderLink?: IRenderFunction<INavLink>;
    // @deprecated
    selectedAriaLabel?: string;
    selectedKey?: string;
    styles?: IStyleFunctionOrObject<INavStyleProps, INavStyles>;
    theme?: ITheme;
}

// @public (undocumented)
export interface INavState {
    // (undocumented)
    isGroupCollapsed: {
        [key: string]: boolean;
    };
    // (undocumented)
    isLinkExpandStateChanged?: boolean;
    // (undocumented)
    selectedKey?: string;
}

// @public (undocumented)
export interface INavStyleProps {
    className?: string;
    groups: INavLinkGroup[] | null;
    isButtonEntry?: boolean;
    isDisabled?: boolean;
    isExpanded?: boolean;
    isGroup?: boolean;
    isLink?: boolean;
    isOnTop?: boolean;
    isSelected?: boolean;
    leftPadding?: number;
    leftPaddingExpanded?: number;
    navHeight?: number;
    position?: number;
    rightPadding?: number;
    theme: ITheme;
}

// @public (undocumented)
export interface INavStyles {
    chevronButton: IStyle;
    chevronIcon: IStyle;
    compositeLink: IStyle;
    group: IStyle;
    groupContent: IStyle;
    link: IStyle;
    linkText: IStyle;
    navItem: IStyle;
    navItems: IStyle;
    root: IStyle;
}

export { IObjectWithKey }

// @public (undocumented)
export interface IOverflowSet {
    focus(forceIntoFirstElement?: boolean): boolean;
    focusElement(childElement?: HTMLElement): boolean;
}

// @public (undocumented)
export interface IOverflowSetItemProps {
    [propertyName: string]: any;
    key: string;
    keytipProps?: IKeytipProps;
}

// @public (undocumented)
export interface IOverflowSetProps extends React.ClassAttributes<OverflowSetBase> {
    className?: string;
    componentRef?: IRefObject<IOverflowSet>;
    // @deprecated
    doNotContainWithinFocusZone?: boolean;
    // @deprecated
    focusZoneProps?: IFocusZoneProps;
    items?: IOverflowSetItemProps[];
    itemSubMenuProvider?: (item: IOverflowSetItemProps) => any[] | undefined;
    keytipSequences?: string[];
    onRenderItem: (item: IOverflowSetItemProps) => any;
    onRenderOverflowButton: IRenderFunction<any[]>;
    overflowItems?: IOverflowSetItemProps[];
    overflowSide?: 'start' | 'end';
    role?: string;
    styles?: IStyleFunctionOrObject<IOverflowSetProps, IOverflowSetStyles>;
    vertical?: boolean;
}

// @public
export type IOverflowSetStyleProps = Pick<IOverflowSetProps, 'vertical' | 'className'>;

// @public (undocumented)
export interface IOverflowSetStyles {
    item?: IStyle;
    overflowButton?: IStyle;
    root?: IStyle;
}

// @public (undocumented)
export interface IOverlay {
}

// @public (undocumented)
export interface IOverlayProps extends React.HTMLAttributes<HTMLElement> {
    allowTouchBodyScroll?: boolean;
    className?: string;
    componentRef?: IRefObject<IOverlay>;
    isDarkThemed?: boolean;
    // (undocumented)
    onClick?: () => void;
    styles?: IStyleFunctionOrObject<IOverlayStyleProps, IOverlayStyles>;
    theme?: ITheme;
}

// @public (undocumented)
export interface IOverlayStyleProps {
    className?: string;
    isDark?: boolean;
    isNone?: boolean;
    theme: ITheme;
}

// @public (undocumented)
export interface IOverlayStyles {
    root: IStyle;
}

// @public (undocumented)
export interface IPage<T = any> {
    // (undocumented)
    data?: any;
    // (undocumented)
    height: number;
    // (undocumented)
    isSpacer?: boolean;
    // (undocumented)
    isVisible?: boolean;
    // (undocumented)
    itemCount: number;
    // (undocumented)
    items: T[] | undefined;
    // (undocumented)
    key: string;
    // (undocumented)
    startIndex: number;
    // (undocumented)
    style: React.CSSProperties;
    // (undocumented)
    top: number;
}

// @public (undocumented)
export interface IPageProps<T = any> extends React.HTMLAttributes<HTMLDivElement>, React.ClassAttributes<HTMLDivElement> {
    page: IPage<T>;
    role?: string;
}

// @public (undocumented)
export interface IPageSpecification {
    data?: any;
    height?: number;
    itemCount?: number;
    key?: string;
}

// @public (undocumented)
export interface IPanel {
    dismiss: (ev?: React.KeyboardEvent<HTMLElement>) => void;
    open: () => void;
}

// @public
export interface IPanelHeaderRenderer extends IRenderFunction<IPanelProps> {
    // (undocumented)
    (props?: IPanelProps, defaultRender?: IPanelHeaderRenderer, headerTextId?: string | undefined): JSX.Element | null;
}

// Warning: (ae-forgotten-export) The symbol "PanelBase" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export interface IPanelProps extends React.HTMLAttributes<PanelBase> {
    allowTouchBodyScroll?: boolean;
    className?: string;
    closeButtonAriaLabel?: string;
    // @deprecated
    componentId?: string;
    componentRef?: IRefObject<IPanel>;
    customWidth?: string;
    elementToFocusOnDismiss?: HTMLElement;
    // @deprecated
    firstFocusableSelector?: string;
    focusTrapZoneProps?: IFocusTrapZoneProps;
    // @deprecated
    forceFocusInsideTrap?: boolean;
    hasCloseButton?: boolean;
    headerClassName?: string;
    headerText?: string;
    headerTextProps?: React.HTMLAttributes<HTMLDivElement>;
    // @deprecated
    ignoreExternalFocusing?: boolean;
    isBlocking?: boolean;
    isFooterAtBottom?: boolean;
    isHiddenOnDismiss?: boolean;
    isLightDismiss?: boolean;
    isOpen?: boolean;
    layerProps?: ILayerProps;
    onDismiss?: (ev?: React.SyntheticEvent<HTMLElement>) => void;
    onDismissed?: () => void;
    onLightDismissClick?: () => void;
    onOpen?: () => void;
    onOpened?: () => void;
    onOuterClick?: () => void;
    onRenderBody?: IRenderFunction<IPanelProps>;
    onRenderFooter?: IRenderFunction<IPanelProps>;
    onRenderFooterContent?: IRenderFunction<IPanelProps>;
    onRenderHeader?: IPanelHeaderRenderer;
    onRenderNavigation?: IRenderFunction<IPanelProps>;
    onRenderNavigationContent?: IRenderFunction<IPanelProps>;
    overlayProps?: IOverlayProps;
    popupProps?: IPopupProps;
    styles?: IStyleFunctionOrObject<IPanelStyleProps, IPanelStyles>;
    theme?: ITheme;
    type?: PanelType;
}

// @public (undocumented)
export interface IPanelStyleProps {
    className?: string;
    focusTrapZoneClassName?: string;
    hasCloseButton?: boolean;
    hasCustomNavigation?: boolean;
    headerClassName?: string;
    isAnimating?: boolean;
    isFooterAtBottom?: boolean;
    isFooterSticky?: boolean;
    isHiddenOnDismiss?: boolean;
    isOnRightSide?: boolean;
    isOpen?: boolean;
    theme: ITheme;
    type?: PanelType;
}

// @public (undocumented)
export interface IPanelStyles {
    // @deprecated
    closeButton?: IStyle;
    commands: IStyle;
    content: IStyle;
    contentInner: IStyle;
    footer: IStyle;
    footerInner: IStyle;
    header: IStyle;
    headerText: IStyle;
    hiddenPanel: IStyle;
    main: IStyle;
    navigation: IStyle;
    overlay: IStyle;
    root: IStyle;
    scrollableContent: IStyle;
    subComponentStyles: IPanelSubComponentStyles;
}

// @public (undocumented)
export interface IPanelSubComponentStyles {
    closeButton: Partial<IButtonStyles>;
}

// @public (undocumented)
export interface IPeopleFloatingPickerProps extends IBaseFloatingPickerProps<IPersonaProps> {
}

// @public (undocumented)
export interface IPeoplePickerItemProps extends IPickerItemProps<IExtendedPersonaProps> {
}

// @public
export interface IPeoplePickerItemSelectedProps extends IPickerItemProps<IPersonaProps & {
    ValidationState: ValidationState;
}>, IPeoplePickerItemSharedProps {
    styles?: IStyleFunctionOrObject<IPeoplePickerItemSelectedStyleProps, IPeoplePickerItemSelectedStyles>;
}

// @public
export type IPeoplePickerItemSelectedStyleProps = Required<Pick<IPeoplePickerItemSelectedProps, 'theme'>> & Pick<IPeoplePickerItemSelectedProps, 'className' | 'selected' | 'disabled'> & {
    invalid?: boolean;
};

// @public
export interface IPeoplePickerItemSelectedStyles {
    itemContent: IStyle;
    removeButton: IStyle;
    root: IStyle;
    subComponentStyles: IPeoplePickerItemSelectedSubComponentStyles;
}

// @public
export interface IPeoplePickerItemSelectedSubComponentStyles {
    persona: IStyleFunctionOrObject<IPersonaStyleProps, any>;
    personaCoin?: IStyleFunctionOrObject<IPersonaCoinStyleProps, any>;
}

// @public
export interface IPeoplePickerItemSharedProps {
    className?: string;
    theme?: ITheme;
}

// @public (undocumented)
export interface IPeoplePickerItemState {
    // (undocumented)
    contextualMenuVisible: boolean;
}

// @public
export interface IPeoplePickerItemSuggestionProps extends IPeoplePickerItemSharedProps {
    compact?: boolean;
    personaProps?: IPersonaProps;
    styles?: IStyleFunctionOrObject<IPeoplePickerItemSuggestionStyleProps, IPeoplePickerItemSuggestionStyles>;
    suggestionsProps?: IBasePickerSuggestionsProps;
}

// @public
export type IPeoplePickerItemSuggestionStyleProps = Required<Pick<IPeoplePickerItemSuggestionProps, 'theme'>> & Pick<IPeoplePickerItemSuggestionProps, 'className'> & {};

// @public
export interface IPeoplePickerItemSuggestionStyles {
    personaWrapper: IStyle;
    root: IStyle;
    subComponentStyles: IPeoplePickerItemSelectedSubComponentStyles;
}

// @public @deprecated
export interface IPeoplePickerItemWithMenuProps extends IPickerItemProps<IPersonaWithMenu> {
}

// @public
export interface IPeoplePickerProps extends IBasePickerProps<IPersonaProps> {
}

// @public (undocumented)
export interface IPersona {
}

// @public (undocumented)
export interface IPersonaCoinProps extends IPersonaSharedProps {
    className?: string;
    componentRef?: IRefObject<{}>;
    styles?: IStyleFunctionOrObject<IPersonaCoinStyleProps, IPersonaCoinStyles>;
}

// @public (undocumented)
export interface IPersonaCoinStyleProps {
    className?: string;
    coinSize?: number;
    showUnknownPersonaCoin?: boolean;
    size?: PersonaSize;
    theme: ITheme;
}

// @public (undocumented)
export interface IPersonaCoinStyles {
    // (undocumented)
    coin: IStyle;
    // (undocumented)
    image: IStyle;
    // (undocumented)
    imageArea: IStyle;
    // (undocumented)
    initials: IStyle;
    // (undocumented)
    size10WithoutPresenceIcon: IStyle;
}

// @public (undocumented)
export interface IPersonaPresenceProps extends IPersonaSharedProps {
    componentRef?: IRefObject<{}>;
    styles?: IStyleFunctionOrObject<IPersonaPresenceStyleProps, IPersonaPresenceStyles>;
}

// @public (undocumented)
export type IPersonaPresenceStyleProps = Required<Pick<IPersonaSharedProps, 'theme'>> & Pick<IPersonaSharedProps, 'presence' | 'isOutOfOffice' | 'size' | 'presenceColors'> & Pick<IPersonaProps, 'className'>;

// @public (undocumented)
export interface IPersonaPresenceStyles {
    // (undocumented)
    presence: IStyle;
    // (undocumented)
    presenceIcon: IStyle;
}

// @public (undocumented)
export interface IPersonaProps extends IPersonaSharedProps {
    className?: string;
    componentRef?: IRefObject<IPersona>;
    onRenderOptionalText?: IRenderFunction<IPersonaProps>;
    onRenderPrimaryText?: IRenderFunction<IPersonaProps>;
    onRenderSecondaryText?: IRenderFunction<IPersonaProps>;
    onRenderTertiaryText?: IRenderFunction<IPersonaProps>;
    styles?: IStyleFunctionOrObject<IPersonaStyleProps, IPersonaStyles>;
}

// @public (undocumented)
export interface IPersonaSharedProps extends React.HTMLAttributes<HTMLDivElement>, React.RefAttributes<HTMLDivElement> {
    allowPhoneInitials?: boolean;
    coinProps?: IPersonaCoinProps;
    coinSize?: number;
    hidePersonaDetails?: boolean;
    imageAlt?: string;
    imageInitials?: string;
    imageShouldFadeIn?: boolean;
    imageShouldStartVisible?: boolean;
    imageUrl?: string;
    initialsColor?: PersonaInitialsColor | string;
    isOutOfOffice?: boolean;
    onPhotoLoadingStateChange?: (newImageLoadState: ImageLoadState) => void;
    // @deprecated
    onRenderCoin?: IRenderFunction<IPersonaSharedProps>;
    onRenderInitials?: IRenderFunction<IPersonaSharedProps>;
    onRenderPersonaCoin?: IRenderFunction<IPersonaSharedProps>;
    optionalText?: string;
    presence?: PersonaPresence;
    presenceColors?: {
        available: string;
        away: string;
        busy: string;
        dnd: string;
        offline: string;
        oof: string;
        background: string;
    };
    presenceTitle?: string;
    // @deprecated
    primaryText?: string;
    secondaryText?: string;
    showInitialsUntilImageLoads?: boolean;
    // (undocumented)
    showSecondaryText?: boolean;
    showUnknownPersonaCoin?: boolean;
    size?: PersonaSize;
    tertiaryText?: string;
    text?: string;
    theme?: ITheme;
}

// @public (undocumented)
export interface IPersonaStyleProps {
    className?: string;
    coinSize?: number;
    presence?: PersonaPresence;
    // (undocumented)
    showSecondaryText?: boolean;
    size?: PersonaSize;
    theme: ITheme;
}

// @public (undocumented)
export interface IPersonaStyles {
    // (undocumented)
    details: IStyle;
    // (undocumented)
    optionalText: IStyle;
    // (undocumented)
    primaryText: IStyle;
    // (undocumented)
    root: IStyle;
    // (undocumented)
    secondaryText: IStyle;
    // (undocumented)
    tertiaryText: IStyle;
    // (undocumented)
    textContent: IStyle;
}

// @public @deprecated
export interface IPersonaWithMenu extends IPersonaProps {
    menuItems?: IContextualMenuItem[];
}

// @public
export type IPickerAriaIds = {
    selectedSuggestionAlert: string;
    selectedItems: string;
    suggestionList: string;
};

// @public
export interface IPickerItem {
}

// @public
export interface IPickerItemProps<T> extends React.AllHTMLAttributes<HTMLElement> {
    componentRef?: IRefObject<IPickerItem>;
    index: number;
    item: T;
    key?: string | number;
    onItemChange?: (item: T, index: number) => void;
    onRemoveItem?: () => void;
    removeButtonAriaLabel?: string;
    selected?: boolean;
}

// @public (undocumented)
export interface IPlainCard {
}

// @public
export interface IPlainCardProps extends IBaseCardProps<IPlainCard, IPlainCardStyles, IPlainCardStyleProps> {
    onRenderPlainCard?: IRenderFunction<any>;
}

// @public (undocumented)
export interface IPlainCardStyleProps extends IBaseCardStyleProps {
}

// @public (undocumented)
export interface IPlainCardStyles extends IBaseCardStyles {
}

export { IPoint }

// @public (undocumented)
export interface IPopupProps extends React.HTMLAttributes<Popup> {
    ariaDescribedBy?: string;
    ariaLabel?: string;
    ariaLabelledBy?: string;
    className?: string;
    onDismiss?: (ev?: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>) => any;
    onRestoreFocus?: (options: {
        originalElement?: HTMLElement | Window;
        containsFocus: boolean;
        documentContainsFocus: boolean;
    }) => void;
    role?: string;
    // @deprecated
    shouldRestoreFocus?: boolean;
}

// @public (undocumented)
export interface IPopupState {
    // (undocumented)
    needsVerticalScrollBar?: boolean;
}

// @public
export interface IPosition {
    // (undocumented)
    [key: string]: number | undefined;
    // (undocumented)
    bottom?: number;
    // (undocumented)
    left?: number;
    // (undocumented)
    right?: number;
    // (undocumented)
    top?: number;
}

// @public (undocumented)
export interface IPositionDirectionalHintData {
    // (undocumented)
    alignmentEdge?: RectangleEdge;
    // (undocumented)
    alignTargetEdge?: boolean;
    // (undocumented)
    isAuto?: boolean;
    // (undocumented)
    targetEdge: RectangleEdge;
}

// @public (undocumented)
export interface IPositionedData {
    alignmentEdge?: RectangleEdge;
    elementPosition: IPosition;
    targetEdge: RectangleEdge;
}

// @public (undocumented)
export interface IPositioningContainer {
}

// @public (undocumented)
export interface IPositioningContainerProps extends IBaseProps<IPositioningContainer>, React.RefAttributes<HTMLDivElement> {
    ariaDescribedBy?: string;
    ariaLabel?: string;
    ariaLabelledBy?: string;
    backgroundColor?: string;
    bounds?: IRectangle;
    children?: ReactNode;
    className?: string;
    componentRef?: IRefObject<IPositioningContainer>;
    coverTarget?: boolean;
    directionalHint?: DirectionalHint;
    directionalHintFixed?: boolean;
    directionalHintForRTL?: DirectionalHint;
    doNotLayer?: boolean;
    finalHeight?: number;
    minPagePadding?: number;
    offsetFromTarget?: number;
    onDismiss?: (ev?: any) => void;
    onLayerMounted?: () => void;
    onPositioned?: (positions?: IPositionedData) => void;
    positioningContainerMaxHeight?: number;
    positioningContainerWidth?: number;
    preventDismissOnScroll?: boolean;
    role?: string;
    setInitialFocus?: boolean;
    target?: HTMLElement | string | MouseEvent | Point | null;
    // @deprecated
    targetPoint?: Point;
    // @deprecated
    useTargetPoint?: boolean;
}

// @public @deprecated (undocumented)
export type IPositioningContainerTypes = IPositioningContainerProps;

// @public (undocumented)
export interface IPositionProps {
    alignTargetEdge?: boolean;
    bounds?: IRectangle;
    coverTarget?: boolean;
    directionalHint?: DirectionalHint;
    directionalHintFixed?: boolean;
    directionalHintForRTL?: DirectionalHint;
    gapSpace?: number;
    // (undocumented)
    target?: Element | MouseEvent | Point;
}

// @public (undocumented)
export interface IProgressIndicatorProps extends React.ClassAttributes<ProgressIndicatorBase> {
    ariaValueText?: string;
    barHeight?: number;
    className?: string;
    description?: React.ReactNode;
    label?: React.ReactNode;
    onRenderProgress?: IRenderFunction<IProgressIndicatorProps>;
    percentComplete?: number;
    progressHidden?: boolean;
    styles?: IStyleFunctionOrObject<IProgressIndicatorStyleProps, IProgressIndicatorStyles>;
    theme?: ITheme;
    // @deprecated
    title?: string;
}

// @public (undocumented)
export interface IProgressIndicatorStyleProps {
    // (undocumented)
    barHeight?: number;
    className?: string;
    // (undocumented)
    indeterminate?: boolean;
    theme: ITheme;
}

// @public (undocumented)
export interface IProgressIndicatorStyles {
    // (undocumented)
    itemDescription: IStyle;
    // (undocumented)
    itemName: IStyle;
    // (undocumented)
    itemProgress: IStyle;
    // (undocumented)
    progressBar: IStyle;
    // (undocumented)
    progressTrack: IStyle;
    root: IStyle;
}

// @public (undocumented)
export interface IRating {
    rating: number;
}

// @public
export interface IRatingProps extends React.HTMLAttributes<HTMLDivElement>, React.RefAttributes<HTMLDivElement> {
    allowZeroStars?: boolean;
    ariaLabelFormat?: string;
    componentRef?: IRefObject<IRating>;
    defaultRating?: number;
    disabled?: boolean;
    // (undocumented)
    getAriaLabel?: (rating: number, max: number) => string;
    icon?: string;
    max?: number;
    // @deprecated
    min?: number;
    onChange?: (event: React.FormEvent<HTMLElement>, rating?: number) => void;
    rating?: number;
    readOnly?: boolean;
    size?: RatingSize;
    styles?: IStyleFunctionOrObject<IRatingStyleProps, IRatingStyles>;
    theme?: ITheme;
    unselectedIcon?: string;
}

// @public (undocumented)
export interface IRatingStyleProps {
    // (undocumented)
    disabled?: boolean;
    // (undocumented)
    readOnly?: boolean;
    // (undocumented)
    theme: ITheme;
}

// @public (undocumented)
export interface IRatingStyles {
    // (undocumented)
    labelText: IStyle;
    // (undocumented)
    ratingButton: IStyle;
    // (undocumented)
    ratingFocusZone: IStyle;
    // (undocumented)
    ratingStar: IStyle;
    // (undocumented)
    ratingStarBack: IStyle;
    // (undocumented)
    ratingStarFront: IStyle;
    // (undocumented)
    ratingStarIsLarge: IStyle;
    // (undocumented)
    ratingStarIsSmall: IStyle;
    // (undocumented)
    root: IStyle;
    // (undocumented)
    rootIsLarge: IStyle;
    // (undocumented)
    rootIsSmall: IStyle;
}

// @public (undocumented)
export interface IRelativePositions {
    // (undocumented)
    beakPosition: {
        position: IPosition | undefined;
        display: 'block';
    };
    // (undocumented)
    calloutPosition: IPosition;
    // (undocumented)
    directionalClassName: string;
    // (undocumented)
    submenuDirection: DirectionalHint;
}

// @public (undocumented)
export interface IRenderGroupHeaderProps extends INavLinkGroup {
    isExpanded?: boolean;
}

// @public (undocumented)
export interface IResizeGroup {
    remeasure(): void;
}

// @public (undocumented)
export interface IResizeGroupProps extends React.HTMLAttributes<ResizeGroupBase | HTMLElement> {
    className?: string;
    componentRef?: IRefObject<IResizeGroup>;
    data: any;
    dataDidRender?: (renderedData: any) => void;
    direction?: ResizeGroupDirection;
    onGrowData?: (prevData: any) => any;
    onReduceData: (prevData: any) => any;
    onRenderData: (data: any) => JSX.Element;
    // @deprecated
    styles?: IStyleFunctionOrObject<IResizeGroupStyleProps, IResizeGroupStyles>;
    theme?: ITheme;
}

// @public (undocumented)
export interface IResizeGroupState {
    dataToMeasure?: any;
    measureContainer?: boolean;
    renderedData?: any;
    resizeDirection?: 'grow' | 'shrink';
}

// @public (undocumented)
export interface IResizeGroupStyleProps {
    className?: string;
    theme: ITheme;
}

// @public (undocumented)
export interface IResizeGroupStyles {
    root: IStyle;
}

// @public
export interface IRGB {
    a?: number;
    b: number;
    g: number;
    r: number;
}

// @public (undocumented)
export interface IScrollablePane {
    forceLayoutUpdate(): void;
    getScrollPosition(): number;
}

// @public (undocumented)
export interface IScrollablePaneContext {
    // (undocumented)
    scrollablePane?: {
        subscribe: (handler: (container: HTMLElement, stickyContainer: HTMLElement) => void) => void;
        unsubscribe: (handler: (container: HTMLElement, stickyContainer: HTMLElement) => void) => void;
        addSticky: (sticky: Sticky) => void;
        removeSticky: (sticky: Sticky) => void;
        updateStickyRefHeights: () => void;
        sortSticky: (sticky: Sticky, sortAgain?: boolean) => void;
        notifySubscribers: (sort?: boolean) => void;
        syncScrollSticky: (sticky: Sticky) => void;
    };
}

// @public (undocumented)
export interface IScrollablePaneProps extends React.HTMLAttributes<HTMLElement | ScrollablePaneBase> {
    className?: string;
    componentRef?: IRefObject<IScrollablePane>;
    initialScrollPosition?: number;
    // (undocumented)
    scrollbarVisibility?: ScrollbarVisibility;
    styles?: IStyleFunctionOrObject<IScrollablePaneStyleProps, IScrollablePaneStyles>;
    theme?: ITheme;
}

// @public (undocumented)
export interface IScrollablePaneState {
    // (undocumented)
    scrollbarHeight: number;
    // (undocumented)
    scrollbarWidth: number;
    // (undocumented)
    stickyBottomHeight: number;
    // (undocumented)
    stickyTopHeight: number;
}

// @public (undocumented)
export interface IScrollablePaneStyleProps {
    className?: string;
    // (undocumented)
    scrollbarVisibility?: IScrollablePaneProps['scrollbarVisibility'];
    theme: ITheme;
}

// @public (undocumented)
export interface IScrollablePaneStyles {
    contentContainer: IStyle;
    root: IStyle;
    stickyAbove: IStyle;
    stickyBelow: IStyle;
    stickyBelowItems: IStyle;
}

// @public (undocumented)
export function isDark(color: IColor): boolean;

// @public (undocumented)
export interface ISearchBox {
    focus(): void;
    hasFocus(): boolean;
}

// @public (undocumented)
export interface ISearchBoxProps extends React.InputHTMLAttributes<HTMLInputElement> {
    ariaLabel?: string;
    className?: string;
    clearButtonProps?: IButtonProps;
    componentRef?: IRefObject<ISearchBox>;
    // @deprecated
    defaultValue?: string;
    disableAnimation?: boolean;
    iconProps?: Pick<IIconProps, Exclude<keyof IIconProps, 'className'>>;
    // @deprecated
    labelText?: string;
    onChange?: (event?: React.ChangeEvent<HTMLInputElement>, newValue?: string) => void;
    // @deprecated
    onChanged?: (newValue: any) => void;
    onClear?: (ev?: any) => void;
    onEscape?: (ev?: any) => void;
    onSearch?: (newValue: any) => void;
    placeholder?: string;
    styles?: IStyleFunctionOrObject<ISearchBoxStyleProps, ISearchBoxStyles>;
    theme?: ITheme;
    underlined?: boolean;
    value?: string;
}

// @public (undocumented)
export interface ISearchBoxState {
    // (undocumented)
    hasFocus?: boolean;
    // (undocumented)
    value?: string;
}

// @public (undocumented)
export interface ISearchBoxStyleProps {
    // (undocumented)
    className?: string;
    // (undocumented)
    disableAnimation?: boolean;
    // (undocumented)
    disabled?: boolean;
    // (undocumented)
    hasFocus?: boolean;
    // (undocumented)
    hasInput?: boolean;
    // (undocumented)
    theme: ITheme;
    // (undocumented)
    underlined?: boolean;
}

// @public (undocumented)
export interface ISearchBoxStyles {
    // (undocumented)
    clearButton?: IStyle;
    // (undocumented)
    field?: IStyle;
    // (undocumented)
    icon?: IStyle;
    // (undocumented)
    iconContainer?: IStyle;
    // (undocumented)
    root?: IStyle;
}

// @public
export interface ISelectableDroppableTextProps<TComponent, TListenerElement> extends React.HTMLAttributes<TListenerElement> {
    ariaLabel?: string;
    calloutProps?: ICalloutProps;
    className?: string;
    componentRef?: IRefObject<TComponent>;
    defaultSelectedKey?: string | number | string[] | number[] | null;
    disabled?: boolean;
    errorMessage?: string;
    id?: string;
    label?: string;
    multiSelect?: boolean;
    onDismiss?: () => void;
    onRenderContainer?: IRenderFunction<ISelectableDroppableTextProps<TComponent, TListenerElement>>;
    onRenderItem?: IRenderFunction<ISelectableOption>;
    onRenderList?: IRenderFunction<ISelectableDroppableTextProps<TComponent, TListenerElement>>;
    onRenderOption?: IRenderFunction<ISelectableOption>;
    openOnKeyboardFocus?: boolean;
    options?: any;
    panelProps?: IPanelProps;
    placeholder?: string;
    required?: boolean;
    selectedKey?: string | number | string[] | number[] | null;
}

// @public (undocumented)
export interface ISelectableOption {
    ariaLabel?: string;
    data?: any;
    disabled?: boolean;
    hidden?: boolean;
    id?: string;
    index?: number;
    itemType?: SelectableOptionMenuItemType;
    key: string | number;
    selected?: boolean;
    text: string;
    title?: string;
}

// @public (undocumented)
export interface ISelectedItemProps<T> extends IPickerItemProps<T> {
    // (undocumented)
    onCopyItem: (item: T) => void;
}

// @public (undocumented)
export interface ISelectedPeopleItemProps extends ISelectedItemProps<IExtendedPersonaProps> {
    // (undocumented)
    onExpandItem?: () => void;
    // (undocumented)
    renderPersonaCoin?: IRenderFunction<IPersonaProps>;
    // (undocumented)
    renderPrimaryText?: IRenderFunction<IPersonaProps>;
}

// @public (undocumented)
export interface ISelectedPeopleProps extends IBaseSelectedItemsListProps<IExtendedPersonaProps> {
    // (undocumented)
    copyMenuItemText?: string;
    // (undocumented)
    editMenuItemText?: string;
    // (undocumented)
    floatingPickerProps?: IBaseFloatingPickerProps<IPersonaProps>;
    // (undocumented)
    getEditingItemText?: (item: IExtendedPersonaProps) => string;
    // (undocumented)
    onExpandGroup?: (item: IExtendedPersonaProps) => void;
    // (undocumented)
    onRenderFloatingPicker?: React.ComponentType<IBaseFloatingPickerProps<IPersonaProps>>;
    // (undocumented)
    removeMenuItemText?: string;
}

export { ISelection }

export { ISelectionOptions }

// @public (undocumented)
export interface ISelectionZone {
    ignoreNextFocus: () => void;
}

// @public (undocumented)
export interface ISelectionZoneProps extends React.ClassAttributes<SelectionZone> {
    componentRef?: () => void;
    disableAutoSelectOnInputElements?: boolean;
    enableTouchInvocationTarget?: boolean;
    enterModalOnTouch?: boolean;
    isSelectedOnFocus?: boolean;
    // @deprecated (undocumented)
    layout?: {};
    onItemContextMenu?: (item?: any, index?: number, ev?: Event) => void | boolean;
    onItemInvoked?: (item?: IObjectWithKey, index?: number, ev?: Event) => void;
    selection: ISelection;
    selectionMode?: SelectionMode;
    selectionPreservedOnEmptyClick?: boolean;
}

// @public (undocumented)
export interface ISelectionZoneState {
    // (undocumented)
    isModal: boolean | undefined;
}

// @public (undocumented)
export interface ISeparator {
}

// @public (undocumented)
export interface ISeparatorProps extends React.HTMLAttributes<HTMLElement> {
    alignContent?: 'start' | 'center' | 'end';
    styles?: IStyleFunctionOrObject<ISeparatorStyleProps, ISeparatorStyles>;
    theme?: ITheme;
    vertical?: boolean;
}

// @public (undocumented)
export type ISeparatorStyleProps = Required<Pick<ISeparatorProps, 'theme'>> & Pick<ISeparatorProps, 'className' | 'alignContent' | 'vertical'>;

// @public (undocumented)
export interface ISeparatorStyles {
    content: IStyle;
    root: IStyle;
}

// @public (undocumented)
export interface IShimmer {
}

// @public (undocumented)
export interface IShimmerCircle {
}

// @public
export interface IShimmerCircleProps extends React.AllHTMLAttributes<HTMLElement> {
    // @deprecated
    borderStyle?: IRawStyle;
    componentRef?: IRefObject<IShimmerCircle>;
    height?: number;
    styles?: IStyleFunctionOrObject<IShimmerCircleStyleProps, IShimmerCircleStyles>;
    theme?: ITheme;
}

// @public
export type IShimmerCircleStyleProps = {
    theme: ITheme;
    height?: number;
    borderStyle?: IRawStyle;
};

// @public
export interface IShimmerCircleStyles {
    root?: IStyle;
    svg?: IStyle;
}

// @public
export interface IShimmerColors {
    background?: string;
    shimmer?: string;
    shimmerWave?: string;
}

// @public
export interface IShimmerElement {
    height?: number;
    type: ShimmerElementType;
    verticalAlign?: 'top' | 'center' | 'bottom';
    width?: number | string;
}

// @public (undocumented)
export interface IShimmerElementsGroup {
}

// @public
export interface IShimmerElementsGroupProps extends React.AllHTMLAttributes<HTMLElement> {
    backgroundColor?: string;
    componentRef?: IRefObject<IShimmerElementsGroup>;
    flexWrap?: boolean;
    rowHeight?: number;
    shimmerElements?: IShimmerElement[];
    styles?: IStyleFunctionOrObject<IShimmerElementsGroupStyleProps, IShimmerElementsGroupStyles>;
    theme?: ITheme;
    width?: string;
}

// @public
export interface IShimmerElementsGroupStyleProps {
    flexWrap?: boolean;
    theme: ITheme;
}

// @public
export interface IShimmerElementsGroupStyles {
    root?: IStyle;
}

// @public (undocumented)
export interface IShimmerGap {
}

// @public
export interface IShimmerGapProps extends React.AllHTMLAttributes<HTMLElement> {
    // @deprecated
    borderStyle?: IRawStyle;
    componentRef?: IRefObject<IShimmerGap>;
    height?: number;
    styles?: IStyleFunctionOrObject<IShimmerGapStyleProps, IShimmerGapStyles>;
    theme?: ITheme;
    width?: number | string;
}

// @public
export type IShimmerGapStyleProps = {
    theme: ITheme;
    height?: number;
    borderStyle?: IRawStyle;
};

// @public
export interface IShimmerGapStyles {
    root?: IStyle;
}

// @public (undocumented)
export interface IShimmerLine {
}

// @public
export interface IShimmerLineProps extends React.AllHTMLAttributes<HTMLElement> {
    // @deprecated
    borderStyle?: IRawStyle;
    componentRef?: IRefObject<IShimmerLine>;
    height?: number;
    styles?: IStyleFunctionOrObject<IShimmerLineStyleProps, IShimmerLineStyles>;
    theme?: ITheme;
    width?: number | string;
}

// @public
export type IShimmerLineStyleProps = {
    theme: ITheme;
    height?: number;
    borderStyle?: IRawStyle;
};

// @public
export interface IShimmerLineStyles {
    bottomLeftCorner?: IStyle;
    bottomRightCorner?: IStyle;
    root?: IStyle;
    topLeftCorner?: IStyle;
    topRightCorner?: IStyle;
}

// @public
export interface IShimmerProps extends React.AllHTMLAttributes<HTMLElement> {
    ariaLabel?: string;
    className?: string;
    // @deprecated (undocumented)
    componentRef?: IRefObject<IShimmer>;
    customElementsGroup?: React.ReactNode;
    isDataLoaded?: boolean;
    shimmerColors?: IShimmerColors;
    shimmerElements?: IShimmerElement[];
    styles?: IStyleFunctionOrObject<IShimmerStyleProps, IShimmerStyles>;
    theme?: ITheme;
    width?: number | string;
}

// @public (undocumented)
export interface IShimmerState {
    contentLoaded?: boolean;
}

// @public
export interface IShimmerStyleProps {
    className?: string;
    isDataLoaded?: boolean;
    shimmerColor?: string;
    shimmerWaveColor?: string;
    theme: ITheme;
    transitionAnimationInterval?: number;
}

// @public
export interface IShimmerStyles {
    dataWrapper?: IStyle;
    root?: IStyle;
    screenReaderText?: IStyle;
    shimmerGradient?: IStyle;
    shimmerWrapper?: IStyle;
}

// @public (undocumented)
export interface ISpinButton {
    focus: () => void;
    value?: string;
}

// @public (undocumented)
export interface ISpinButtonClassNames {
    // (undocumented)
    arrowBox: string;
    // (undocumented)
    icon: string;
    // (undocumented)
    input: string;
    // (undocumented)
    label: string;
    // (undocumented)
    labelWrapper: string;
    // (undocumented)
    root: string;
    // (undocumented)
    spinButtonWrapper: string;
}

// @public (undocumented)
export interface ISpinButtonProps extends React.HTMLAttributes<HTMLDivElement> {
    ariaDescribedBy?: string;
    ariaLabel?: string;
    ariaPositionInSet?: number;
    ariaSetSize?: number;
    ariaValueNow?: number;
    // (undocumented)
    ariaValueText?: string;
    className?: string;
    componentRef?: IRefObject<ISpinButton>;
    decrementButtonAriaLabel?: string;
    decrementButtonIcon?: IIconProps;
    defaultValue?: string;
    disabled?: boolean;
    downArrowButtonStyles?: Partial<IButtonStyles>;
    getClassNames?: (theme: ITheme, disabled: boolean, isFocused: boolean, keyboardSpinDirection: KeyboardSpinDirection, labelPosition?: Position, className?: string) => ISpinButtonClassNames;
    iconButtonProps?: IButtonProps;
    iconProps?: IIconProps;
    incrementButtonAriaLabel?: string;
    incrementButtonIcon?: IIconProps;
    inputProps?: React.InputHTMLAttributes<HTMLElement | HTMLInputElement>;
    keytipProps?: IKeytipProps;
    label?: string;
    labelPosition?: Position;
    max?: number;
    min?: number;
    onBlur?: React.FocusEventHandler<HTMLInputElement>;
    onDecrement?: (value: string, event?: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>) => string | void;
    onFocus?: React.FocusEventHandler<HTMLInputElement>;
    onIncrement?: (value: string, event?: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>) => string | void;
    onValidate?: (value: string, event?: React.SyntheticEvent<HTMLElement>) => string | void;
    precision?: number;
    step?: number;
    styles?: Partial<ISpinButtonStyles>;
    theme?: ITheme;
    title?: string;
    upArrowButtonStyles?: Partial<IButtonStyles>;
    value?: string;
}

// @public (undocumented)
export interface ISpinButtonState {
    isFocused: boolean;
    keyboardSpinDirection: KeyboardSpinDirection;
    value: string;
}

// @public (undocumented)
export interface ISpinButtonStyles {
    arrowButtonsContainer: IStyle;
    arrowButtonsContainerDisabled: IStyle;
    icon: IStyle;
    iconDisabled: IStyle;
    input: IStyle;
    inputDisabled: IStyle;
    inputTextSelected: IStyle;
    label: IStyle;
    // @deprecated
    labelDisabled: IStyle;
    labelWrapper: IStyle;
    labelWrapperBottom: IStyle;
    labelWrapperEnd: IStyle;
    labelWrapperStart: IStyle;
    labelWrapperTop: IStyle;
    root: IStyle;
    spinButtonWrapper: IStyle;
    spinButtonWrapperDisabled: IStyle;
    spinButtonWrapperFocused: IStyle;
    spinButtonWrapperHovered: IStyle;
    spinButtonWrapperTopBottom: IStyle;
}

// @public (undocumented)
export interface ISpinner {
}

// @public
export interface ISpinnerProps extends React.HTMLAttributes<HTMLElement> {
    ariaLabel?: string;
    ariaLive?: 'assertive' | 'polite' | 'off';
    className?: string;
    componentRef?: IRefObject<ISpinner>;
    label?: string;
    labelPosition?: SpinnerLabelPosition;
    size?: SpinnerSize;
    styles?: IStyleFunctionOrObject<ISpinnerStyleProps, ISpinnerStyles>;
    theme?: ITheme;
    // @deprecated
    type?: SpinnerType;
}

// @public
export interface ISpinnerStyleProps {
    className?: string;
    labelPosition?: SpinnerLabelPosition;
    size?: SpinnerSize;
    theme: ITheme;
}

// @public
export interface ISpinnerStyles {
    circle?: IStyle;
    label?: IStyle;
    root?: IStyle;
    screenReaderText?: IStyle;
}

// @public (undocumented)
export interface ISplitButtonClassNames {
    // (undocumented)
    divider?: string;
    // (undocumented)
    flexContainer?: string;
    // (undocumented)
    icon?: string;
    // (undocumented)
    root?: string;
    // (undocumented)
    splitButtonContainer?: string;
}

// @public (undocumented)
export function isRelativeUrl(url: string): boolean;

// @public (undocumented)
export type IStackComponent = IComponent<IStackProps, IStackTokens, IStackStyles>;

// @public (undocumented)
export type IStackItemComponent = IComponent<IStackItemProps, IStackItemTokens, IStackItemStyles>;

// @public (undocumented)
export interface IStackItemProps extends IStackItemSlots, IStyleableComponentProps<IStackItemProps, IStackItemTokens, IStackItemStyles> {
    align?: 'auto' | 'stretch' | 'baseline' | 'start' | 'center' | 'end';
    className?: string;
    disableShrink?: boolean;
    grow?: boolean | number | 'inherit' | 'initial' | 'unset';
    order?: number | string;
    shrink?: boolean | number | 'inherit' | 'initial' | 'unset';
    verticalFill?: boolean;
}

// @public (undocumented)
export type IStackItemSlot = ISlotProp<IStackItemProps>;

// @public (undocumented)
export interface IStackItemSlots {
    // (undocumented)
    root?: IHTMLSlot;
}

// @public (undocumented)
export type IStackItemStyles = IComponentStyles<IStackItemSlots>;

// @public (undocumented)
export type IStackItemStylesReturnType = ReturnType<Extract<IStackItemComponent['styles'], Function>>;

// @public (undocumented)
export type IStackItemTokenReturnType = ReturnType<Extract<IStackItemComponent['tokens'], Function>>;

// @public (undocumented)
export interface IStackItemTokens {
    margin?: number | string;
    padding?: number | string;
}

// @public (undocumented)
export interface IStackProps extends ISlottableProps<IStackSlots>, IStyleableComponentProps<IStackProps, IStackTokens, IStackStyles>, React.HTMLAttributes<HTMLElement> {
    as?: React.ElementType<React.HTMLAttributes<HTMLElement>>;
    disableShrink?: boolean;
    // @deprecated
    gap?: number | string;
    grow?: boolean | number | 'inherit' | 'initial' | 'unset';
    horizontal?: boolean;
    horizontalAlign?: Alignment;
    // @deprecated
    maxHeight?: number | string;
    // @deprecated
    maxWidth?: number | string;
    // @deprecated
    padding?: number | string;
    reversed?: boolean;
    verticalAlign?: Alignment;
    verticalFill?: boolean;
    wrap?: boolean;
}

// @public (undocumented)
export type IStackSlot = ISlotProp<IStackProps>;

// @public (undocumented)
export interface IStackSlots {
    inner?: IHTMLSlot;
    root?: IHTMLSlot;
}

// @public (undocumented)
export type IStackStyles = IComponentStyles<IStackSlots>;

// @public (undocumented)
export type IStackStylesReturnType = ReturnType<Extract<IStackComponent['styles'], Function>>;

// @public (undocumented)
export type IStackTokenReturnType = ReturnType<Extract<IStackComponent['tokens'], Function>>;

// @public (undocumented)
export interface IStackTokens {
    childrenGap?: number | string;
    maxHeight?: number | string;
    maxWidth?: number | string;
    padding?: number | string;
}

// @public (undocumented)
export interface IStickyProps extends React.Props<Sticky> {
    componentRef?: IRefObject<IStickyProps>;
    isScrollSynced?: boolean;
    stickyBackgroundColor?: string;
    stickyClassName?: string;
    stickyPosition?: StickyPositionType;
}

// @public (undocumented)
export interface IStickyState {
    // (undocumented)
    distanceFromTop?: number;
    // (undocumented)
    isStickyBottom: boolean;
    // (undocumented)
    isStickyTop: boolean;
}

// @public
export interface ISuggestionItemProps<T> {
    className?: string;
    componentRef?: IRefObject<ISuggestionsItem>;
    id?: string;
    isSelectedOverride?: boolean;
    onClick: (ev: React.MouseEvent<HTMLButtonElement>) => void;
    onRemoveItem: (ev: React.MouseEvent<HTMLButtonElement>) => void;
    removeButtonAriaLabel?: string;
    RenderSuggestion: (item: T, suggestionItemProps: ISuggestionItemProps<T>) => JSX.Element;
    showRemoveButton?: boolean;
    styles?: IStyleFunctionOrObject<ISuggestionsItemStyleProps, ISuggestionsItemStyles>;
    suggestionModel: ISuggestionModel<T>;
    theme?: ITheme;
}

// @public
export interface ISuggestionModel<T> {
    ariaLabel?: string;
    item: T;
    selected: boolean;
}

// @public
export interface ISuggestions<T> {
    executeSelectedAction: () => void;
    focusAboveSuggestions: () => void;
    focusBelowSuggestions: () => void;
    focusSearchForMoreButton: () => void;
    hasSuggestedAction: () => boolean;
    hasSuggestedActionSelected: () => boolean;
    tryHandleKeyDown: (keyCode: number, currentSuggestionIndex: number) => boolean;
}

// @public (undocumented)
export interface ISuggestionsControlProps<T> extends React.ClassAttributes<any>, ISuggestionsCoreProps<T> {
    className?: string;
    completeSuggestion: () => void;
    footerItemsProps?: ISuggestionsHeaderFooterProps[];
    headerItemsProps?: ISuggestionsHeaderFooterProps[];
    shouldSelectFirstItem?: () => boolean;
    suggestionsFooterContainerAriaLabel?: string;
    suggestionsHeaderContainerAriaLabel?: string;
}

// @public (undocumented)
export interface ISuggestionsControlState<T> {
    // (undocumented)
    selectedFooterIndex: number;
    // (undocumented)
    selectedHeaderIndex: number;
    // (undocumented)
    suggestions: ISuggestionModel<T>[];
}

// @public (undocumented)
export interface ISuggestionsCoreProps<T> extends React.ClassAttributes<any> {
    componentRef?: IRefObject<{}>;
    onRenderSuggestion?: (props: T, suggestionItemProps: ISuggestionItemProps<T>) => JSX.Element;
    onSuggestionClick: (ev?: React.MouseEvent<HTMLElement>, item?: any, index?: number) => void;
    onSuggestionRemove?: (ev?: React.MouseEvent<HTMLElement>, item?: IPersonaProps, index?: number) => void;
    resultsMaximumNumber?: number;
    shouldLoopSelection: boolean;
    showRemoveButtons?: boolean;
    suggestions: ISuggestionModel<T>[];
    suggestionsAvailableAlertText?: string;
    suggestionsContainerAriaLabel?: string;
    suggestionsItemClassName?: string;
}

// @public (undocumented)
export interface ISuggestionsHeaderFooterItemProps {
    // (undocumented)
    className: string | undefined;
    // (undocumented)
    componentRef?: IRefObject<{}>;
    // (undocumented)
    id: string;
    // (undocumented)
    isSelected: boolean;
    // (undocumented)
    onExecute?: () => void;
    // (undocumented)
    renderItem: () => JSX.Element;
}

// @public (undocumented)
export interface ISuggestionsHeaderFooterProps {
    // (undocumented)
    ariaLabel?: string;
    // (undocumented)
    className?: string;
    // (undocumented)
    onExecute?: () => void;
    // (undocumented)
    renderItem: () => JSX.Element;
    // (undocumented)
    shouldShow: () => boolean;
}

// @public
export interface ISuggestionsItem {
}

// @public
export type ISuggestionsItemStyleProps = Required<Pick<ISuggestionItemProps<any>, 'theme'>> & Pick<ISuggestionItemProps<any>, 'className'> & {
    suggested?: boolean;
};

// @public
export interface ISuggestionsItemStyles {
    closeButton: IStyle;
    itemButton: IStyle;
    root: IStyle;
}

// @public
export interface ISuggestionsProps<T> extends React.Props<any> {
    className?: string;
    componentRef?: IRefObject<ISuggestions<T>>;
    createGenericItem?: () => void;
    forceResolveText?: string;
    isLoading?: boolean;
    isMostRecentlyUsedVisible?: boolean;
    isResultsFooterVisible?: boolean;
    isSearching?: boolean;
    loadingText?: string;
    moreSuggestionsAvailable?: boolean;
    mostRecentlyUsedHeaderText?: string;
    noResultsFoundText?: string;
    onGetMoreResults?: () => void;
    onRenderNoResultFound?: IRenderFunction<void>;
    onRenderSuggestion: (props: T, suggestionItemProps: ISuggestionItemProps<T>) => JSX.Element;
    onSuggestionClick: (ev?: React.MouseEvent<HTMLElement>, item?: any, index?: number) => void;
    onSuggestionRemove?: (ev?: React.MouseEvent<HTMLElement>, item?: T | IPersonaProps, index?: number) => void;
    refocusSuggestions?: (keyCode: KeyCodes) => void;
    removeSuggestionAriaLabel?: string;
    resultsFooter?: (props: ISuggestionsProps<T>) => JSX.Element;
    resultsFooterFull?: (props: ISuggestionsProps<T>) => JSX.Element;
    resultsMaximumNumber?: number;
    // @deprecated
    searchErrorText?: string;
    searchForMoreText?: string;
    searchingText?: string;
    showForceResolve?: () => boolean;
    showRemoveButtons?: boolean;
    styles?: IStyleFunctionOrObject<any, any>;
    suggestions: ISuggestionModel<T>[];
    suggestionsAvailableAlertText?: string;
    suggestionsClassName?: string;
    suggestionsContainerAriaLabel?: string;
    suggestionsHeaderText?: string;
    suggestionsItemClassName?: string;
    suggestionsListId?: string;
    theme?: ITheme;
}

// @public (undocumented)
export interface ISuggestionsState {
    // (undocumented)
    selectedActionType: SuggestionActionType;
}

// @public
export type ISuggestionsStyleProps = Required<Pick<ISuggestionsProps<any>, 'theme'>> & Pick<ISuggestionsProps<any>, 'className' | 'suggestionsClassName'> & {
    forceResolveButtonSelected?: boolean;
    searchForMoreButtonSelected?: boolean;
};

// @public
export interface ISuggestionsStyles {
    forceResolveButton: IStyle;
    noSuggestions: IStyle;
    root: IStyle;
    searchForMoreButton: IStyle;
    subComponentStyles: ISuggestionsSubComponentStyles;
    suggestionsAvailable: IStyle;
    suggestionsContainer: IStyle;
    title: IStyle;
}

// @public
export interface ISuggestionsSubComponentStyles {
    spinner: IStyleFunctionOrObject<ISpinnerStyleProps, any>;
}

// @public
export function isValidShade(shade?: Shade): boolean;

// @public (undocumented)
export interface ISwatchColorPickerProps extends React.RefAttributes<HTMLElement> {
    ariaPosInSet?: number;
    ariaSetSize?: number;
    cellBorderWidth?: number;
    cellHeight?: number;
    cellMargin?: number;
    cellShape?: 'circle' | 'square';
    cellWidth?: number;
    className?: string;
    colorCells: IColorCellProps[];
    columnCount: number;
    defaultSelectedId?: string | undefined;
    disabled?: boolean;
    doNotContainWithinFocusZone?: boolean;
    focusOnHover?: boolean;
    getColorGridCellStyles?: IStyleFunctionOrObject<IColorPickerGridCellStyleProps, IColorPickerGridCellStyles>;
    id?: string;
    // @deprecated (undocumented)
    isControlled?: boolean;
    mouseLeaveParentSelector?: string | undefined;
    onCellFocused?: (id?: string, color?: string) => void;
    onCellHovered?: (id?: string, color?: string) => void;
    onChange?: (event: React.FormEvent<HTMLElement>, id: string | undefined, color: string | undefined) => void;
    // @deprecated (undocumented)
    onColorChanged?: (id?: string, color?: string) => void;
    onRenderColorCell?: IRenderFunction<IColorCellProps>;
    selectedId?: string;
    shouldFocusCircularNavigate?: boolean;
    styles?: IStyleFunctionOrObject<ISwatchColorPickerStyleProps, ISwatchColorPickerStyles>;
    theme?: ITheme;
}

// @public
export interface ISwatchColorPickerStyleProps {
    cellMargin?: number;
    className?: string;
    theme: ITheme;
}

// @public
export interface ISwatchColorPickerStyles {
    focusedContainer?: IStyle;
    root: IStyle;
    tableCell: IStyle;
}

// @public
export interface ITag {
    key: string | number;
    name: string;
}

// @public
export interface ITagItemProps extends IPickerItemProps<ITag> {
    className?: string;
    enableTagFocusInDisabledPicker?: boolean;
    styles?: IStyleFunctionOrObject<ITagItemStyleProps, ITagItemStyles>;
    theme?: ITheme;
    title?: string;
}

// @public
export type ITagItemStyleProps = Required<Pick<ITagItemProps, 'theme'>> & Pick<ITagItemProps, 'className' | 'selected' | 'disabled'> & {};

// @public
export interface ITagItemStyles {
    close: IStyle;
    root: IStyle;
    text: IStyle;
}

// @public
export interface ITagItemSuggestionProps extends React.AllHTMLAttributes<HTMLElement> {
    className?: string;
    styles?: IStyleFunctionOrObject<ITagItemSuggestionStyleProps, ITagItemSuggestionStyles>;
    theme?: ITheme;
}

// @public
export type ITagItemSuggestionStyleProps = Required<Pick<ITagItemSuggestionProps, 'theme'>> & Pick<ITagItemSuggestionProps, 'className'> & {};

// @public
export interface ITagItemSuggestionStyles {
    suggestionTextOverflow?: IStyle;
}

// @public
export interface ITagPickerProps extends IBasePickerProps<ITag> {
}

// @public (undocumented)
export interface ITeachingBubble {
    focus(): void;
}

// @public
export interface ITeachingBubbleProps extends React.ClassAttributes<TeachingBubbleBase | TeachingBubbleContentBase>, IAccessiblePopupProps {
    ariaDescribedBy?: string;
    ariaLabelledBy?: string;
    calloutProps?: ICalloutProps;
    componentRef?: IRefObject<ITeachingBubble>;
    focusTrapZoneProps?: IFocusTrapZoneProps;
    footerContent?: string | JSX.Element;
    hasCloseButton?: boolean;
    // @deprecated (undocumented)
    hasCloseIcon?: boolean;
    hasCondensedHeadline?: boolean;
    hasSmallHeadline?: boolean;
    headline?: string;
    illustrationImage?: IImageProps;
    isWide?: boolean;
    onDismiss?: (ev?: any) => void;
    primaryButtonProps?: IButtonProps;
    secondaryButtonProps?: IButtonProps;
    styles?: IStyleFunctionOrObject<ITeachingBubbleStyleProps, ITeachingBubbleStyles>;
    target?: Target;
    // @deprecated (undocumented)
    targetElement?: HTMLElement;
    theme?: ITheme;
}

// @public (undocumented)
export interface ITeachingBubbleState {
    // (undocumented)
    isTeachingBubbleVisible?: boolean;
}

// @public (undocumented)
export type ITeachingBubbleStyleProps = Required<Pick<ITeachingBubbleProps, 'theme'>> & Pick<ITeachingBubbleProps, 'hasCondensedHeadline' | 'hasSmallHeadline' | 'isWide'> & {
    calloutProps?: ICalloutContentStyleProps;
    primaryButtonClassName?: string;
    secondaryButtonClassName?: string;
    hasCloseButton?: boolean;
    hasHeadline?: boolean;
};

// @public (undocumented)
export interface ITeachingBubbleStyles {
    // (undocumented)
    body: IStyle;
    // (undocumented)
    bodyContent: IStyle;
    // (undocumented)
    closeButton: IStyle;
    // (undocumented)
    content: IStyle;
    // (undocumented)
    footer: IStyle;
    // (undocumented)
    header: IStyle;
    // (undocumented)
    headline: IStyle;
    // (undocumented)
    imageContent: IStyle;
    // (undocumented)
    primaryButton: IStyle;
    // (undocumented)
    root: IStyle;
    // (undocumented)
    secondaryButton: IStyle;
    // (undocumented)
    subComponentStyles?: ITeachingBubbleSubComponentStyles;
    // (undocumented)
    subText: IStyle;
}

// @public (undocumented)
export interface ITeachingBubbleSubComponentStyles {
    callout: IStyleFunctionOrObject<any, any>;
}

// @public (undocumented)
export type ITextComponent = IComponent<ITextProps, ITextTokens, ITextStyles>;

// @public (undocumented)
export interface ITextField {
    blur: () => void;
    focus: () => void;
    select: () => void;
    selectionEnd: number | null;
    selectionStart: number | null;
    setSelectionEnd: (value: number) => void;
    setSelectionRange: (start: number, end: number) => void;
    setSelectionStart: (value: number) => void;
    value: string | undefined;
}

// @public
export interface ITextFieldProps extends React.AllHTMLAttributes<HTMLInputElement | HTMLTextAreaElement> {
    ariaLabel?: string;
    autoAdjustHeight?: boolean;
    autoComplete?: string;
    borderless?: boolean;
    className?: string;
    componentRef?: IRefObject<ITextField>;
    defaultValue?: string;
    deferredValidationTime?: number;
    description?: string;
    disabled?: boolean;
    // @deprecated
    elementRef?: React.Ref<HTMLDivElement>;
    errorMessage?: string | JSX.Element;
    iconProps?: IIconProps;
    inputClassName?: string;
    label?: string;
    multiline?: boolean;
    onChange?: (event: React.FormEvent<HTMLInputElement | HTMLTextAreaElement>, newValue?: string) => void;
    onGetErrorMessage?: (value: string) => string | JSX.Element | PromiseLike<string | JSX.Element> | undefined;
    onNotifyValidationResult?: (errorMessage: string | JSX.Element, value: string | undefined) => void;
    onRenderDescription?: IRenderFunction<ITextFieldProps>;
    onRenderLabel?: IRenderFunction<ITextFieldProps>;
    onRenderPrefix?: IRenderFunction<ITextFieldProps>;
    onRenderSuffix?: IRenderFunction<ITextFieldProps>;
    prefix?: string;
    readOnly?: boolean;
    resizable?: boolean;
    styles?: IStyleFunctionOrObject<ITextFieldStyleProps, ITextFieldStyles>;
    suffix?: string;
    theme?: ITheme;
    underlined?: boolean;
    validateOnFocusIn?: boolean;
    validateOnFocusOut?: boolean;
    validateOnLoad?: boolean;
    value?: string;
}

// Warning: (ae-internal-missing-underscore) The name "ITextFieldSnapshot" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface ITextFieldSnapshot {
    selection?: [number | null, number | null];
}

// Warning: (ae-internal-missing-underscore) The name "ITextFieldState" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface ITextFieldState {
    errorMessage: string | JSX.Element;
    isFocused?: boolean;
    uncontrolledValue: string | undefined;
}

// @public (undocumented)
export type ITextFieldStyleProps = Required<Pick<ITextFieldProps, 'theme'>> & Pick<ITextFieldProps, 'className' | 'disabled' | 'inputClassName' | 'required' | 'multiline' | 'borderless' | 'resizable' | 'underlined' | 'autoAdjustHeight'> & {
    hasErrorMessage?: boolean;
    hasIcon?: boolean;
    hasLabel?: boolean;
    focused?: boolean;
};

// @public (undocumented)
export interface ITextFieldStyles {
    description: IStyle;
    errorMessage: IStyle;
    field: IStyle;
    fieldGroup: IStyle;
    icon: IStyle;
    prefix: IStyle;
    root: IStyle;
    subComponentStyles: ITextFieldSubComponentStyles;
    suffix: IStyle;
    wrapper: IStyle;
}

// @public (undocumented)
export interface ITextFieldSubComponentStyles {
    label: IStyleFunctionOrObject<any, any>;
}

// @public
export interface ITextProps extends ISlottableProps<ITextSlots>, IStyleableComponentProps<ITextProps, ITextTokens, ITextStyles>, React.HTMLAttributes<HTMLElement> {
    as?: React.ElementType<React.HTMLAttributes<HTMLElement>>;
    block?: boolean;
    nowrap?: boolean;
    variant?: keyof IFontStyles;
}

// @public (undocumented)
export type ITextSlot = ISlotProp<ITextProps, string>;

// @public (undocumented)
export interface ITextSlots {
    // (undocumented)
    root?: IHTMLSlot;
}

// @public (undocumented)
export type ITextStyles = IComponentStyles<ITextSlots>;

// @public (undocumented)
export type ITextStylesReturnType = ReturnType<Extract<ITextComponent['styles'], Function>>;

// @public (undocumented)
export type ITextTokenReturnType = ReturnType<Extract<ITextComponent['tokens'], Function>>;

// @public (undocumented)
export interface ITextTokens {
}

// @public (undocumented)
export interface IThemeRules {
    // (undocumented)
    [key: string]: IThemeSlotRule;
}

// @public (undocumented)
export interface IThemeSlotRule {
    asShade?: Shade;
    color?: IColor;
    dependentRules: IThemeSlotRule[];
    inherits?: IThemeSlotRule;
    isBackgroundShade?: boolean;
    isCustomized?: boolean;
    name: string;
    value?: string;
}

// @public (undocumented)
export interface ITooltip {
}

// @public (undocumented)
export interface ITooltipHost {
    dismiss: () => void;
    show: () => void;
}

// @public
export interface ITooltipHostProps extends React.HTMLAttributes<HTMLDivElement | TooltipHostBase> {
    calloutProps?: ICalloutProps;
    className?: string;
    closeDelay?: number;
    componentRef?: IRefObject<ITooltipHost>;
    content?: string | JSX.Element | JSX.Element[];
    delay?: TooltipDelay;
    directionalHint?: DirectionalHint;
    directionalHintForRTL?: DirectionalHint;
    hostClassName?: string;
    id?: string;
    onTooltipToggle?(isTooltipVisible: boolean): void;
    overflowMode?: TooltipOverflowMode;
    setAriaDescribedBy?: boolean;
    styles?: IStyleFunctionOrObject<ITooltipHostStyleProps, ITooltipHostStyles>;
    theme?: ITheme;
    tooltipProps?: ITooltipProps;
}

// @public (undocumented)
export interface ITooltipHostState {
    // (undocumented)
    isAriaPlaceholderRendered: boolean;
    // (undocumented)
    isTooltipVisible: boolean;
}

// @public (undocumented)
export interface ITooltipHostStyleProps {
    // (undocumented)
    className?: string;
    // (undocumented)
    theme: ITheme;
}

// @public (undocumented)
export interface ITooltipHostStyles {
    root: IStyle;
}

// @public (undocumented)
export interface ITooltipProps extends React.HTMLAttributes<HTMLDivElement | TooltipBase> {
    calloutProps?: ICalloutProps;
    componentRef?: IRefObject<ITooltip>;
    content?: string | JSX.Element | JSX.Element[];
    delay?: TooltipDelay;
    directionalHint?: DirectionalHint;
    directionalHintForRTL?: DirectionalHint;
    maxWidth?: string | null;
    onRenderContent?: IRenderFunction<ITooltipProps>;
    styles?: IStyleFunctionOrObject<ITooltipStyleProps, ITooltipStyles>;
    targetElement?: HTMLElement;
    theme?: ITheme;
}

// @public (undocumented)
export interface ITooltipStyleProps {
    beakWidth?: number;
    // (undocumented)
    className?: string;
    // @deprecated
    delay?: TooltipDelay;
    gapSpace?: number;
    maxWidth?: string;
    // (undocumented)
    theme: ITheme;
}

// @public (undocumented)
export interface ITooltipStyles {
    content: IStyle;
    root: IStyle;
    subText: IStyle;
}

// @public (undocumented)
export interface IUniqueKeytip {
    // (undocumented)
    keytip: IKeytipProps;
    // (undocumented)
    uniqueID: string;
}

// @public @deprecated (undocumented)
export interface IVerticalDividerClassNames {
    divider: string;
    wrapper: string;
}

// @public
export interface IVerticalDividerProps {
    className?: string;
    // @deprecated (undocumented)
    getClassNames?: (theme: ITheme) => IVerticalDividerClassNames;
    styles?: IStyleFunctionOrObject<IVerticalDividerPropsStyles, IVerticalDividerStyles>;
    theme?: ITheme;
}

// @public
export type IVerticalDividerPropsStyles = Pick<IVerticalDividerProps, 'theme' | 'getClassNames' | 'className'>;

// @public
export interface IVerticalDividerStyles {
    divider: IStyle;
    wrapper: IStyle;
}

// @public
export interface IWindowWithSegments extends Window {
    // (undocumented)
    getWindowSegments?: () => DOMRect[];
}

// @public (undocumented)
export enum KeyboardSpinDirection {
    // (undocumented)
    down = -1,
    // (undocumented)
    notSpinning = 0,
    // (undocumented)
    up = 1
}

// @public
export class Keytip extends React.Component<IKeytipProps, {}> {
    // (undocumented)
    render(): JSX.Element;
}

// @public
export const KeytipData: React.FunctionComponent<IKeytipDataProps & IRenderComponent<{}>>;

// @public (undocumented)
export type KeytipDataOptions = IKeytipDataProps;

// @public (undocumented)
export namespace KeytipEvents {
    const // (undocumented)
    KEYTIP_ADDED = "keytipAdded";
    const // (undocumented)
    KEYTIP_REMOVED = "keytipRemoved";
    const // (undocumented)
    KEYTIP_UPDATED = "keytipUpdated";
    const // (undocumented)
    PERSISTED_KEYTIP_ADDED = "persistedKeytipAdded";
    const // (undocumented)
    PERSISTED_KEYTIP_REMOVED = "persistedKeytipRemoved";
    const // (undocumented)
    PERSISTED_KEYTIP_EXECUTE = "persistedKeytipExecute";
    const // (undocumented)
    ENTER_KEYTIP_MODE = "enterKeytipMode";
    const // (undocumented)
    EXIT_KEYTIP_MODE = "exitKeytipMode";
}

// @public (undocumented)
export const KeytipLayer: React.FunctionComponent<IKeytipLayerProps>;

// @public
export class KeytipLayerBase extends React.Component<IKeytipLayerProps, IKeytipLayerState> {
    constructor(props: IKeytipLayerProps, context: any);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    static defaultProps: IKeytipLayerProps;
    // (undocumented)
    getCurrentSequence(): string;
    // Warning: (ae-forgotten-export) The symbol "KeytipTree" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    getKeytipTree(): KeytipTree;
    processInput(key: string, ev?: React.KeyboardEvent<HTMLElement>): void;
    processTransitionInput(transitionKey: IKeytipTransitionKey, ev?: React.KeyboardEvent<HTMLElement>): void;
    // (undocumented)
    render(): JSX.Element;
    showKeytips(ids: string[]): void;
    }

// @public
export class KeytipManager {
    addParentOverflow(keytipProps: IKeytipProps): IKeytipProps;
    // (undocumented)
    delayUpdatingKeytipChange: boolean;
    enterKeytipMode(): void;
    exitKeytipMode(): void;
    static getInstance(): KeytipManager;
    getKeytips(): IKeytipProps[];
    init(delayUpdatingKeytipChange: boolean): void;
    // (undocumented)
    inKeytipMode: boolean;
    // (undocumented)
    keytips: {
        [key: string]: IUniqueKeytip;
    };
    menuExecute(overflowButtonSequences: string[], keytipSequences: string[]): void;
    // (undocumented)
    persistedKeytips: {
        [key: string]: IUniqueKeytip;
    };
    register(keytipProps: IKeytipProps, persisted?: boolean): string;
    // (undocumented)
    sequenceMapping: {
        [key: string]: IKeytipProps;
    };
    // (undocumented)
    shouldEnterKeytipMode: boolean;
    unregister(keytipToRemove: IKeytipProps, uniqueID: string, persisted?: boolean): void;
    update(keytipProps: IKeytipProps, uniqueID: string): void;
}

// @public (undocumented)
export type KeytipTransitionModifier = typeof KeyCodes.shift | typeof KeyCodes.ctrl | typeof KeyCodes.alt | typeof KeyCodes.leftWindow;

// @public (undocumented)
export const KTP_ARIA_SEPARATOR = ", ";

// @public (undocumented)
export const KTP_FULL_PREFIX: string;

// @public (undocumented)
export const KTP_LAYER_ID = "ktp-layer-id";

// @public (undocumented)
export const KTP_PREFIX = "ktp";

// @public (undocumented)
export const KTP_SEPARATOR = "-";

// @public
export function ktpTargetFromId(keytipId: string): string;

// @public
export function ktpTargetFromSequences(keySequences: string[]): string;

// @public (undocumented)
export const Label: React.FunctionComponent<ILabelProps>;

// @public (undocumented)
export class LabelBase extends React.Component<ILabelProps, {}> {
    // (undocumented)
    render(): JSX.Element;
}

// @public (undocumented)
export const Layer: React.FunctionComponent<ILayerProps>;

// @public (undocumented)
export class LayerBase extends React.Component<ILayerProps, ILayerBaseState> {
    constructor(props: ILayerProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentDidUpdate(): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    static defaultProps: ILayerProps;
    // (undocumented)
    render(): React.ReactNode;
    }

// Warning: (ae-forgotten-export) The symbol "ILayerHostProps" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export class LayerHost extends React.Component<ILayerHostProps> {
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    render(): JSX.Element;
    // (undocumented)
    shouldComponentUpdate(): boolean;
}

// @public
export class List<T = any> extends React.Component<IListProps<T>, IListState<T>> implements IList {
    constructor(props: IListProps<T>);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentDidUpdate(): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    static defaultProps: {
        startIndex: number;
        onRenderCell: (item: any, index: number, containsFocus: boolean) => JSX.Element;
        renderedWindowsAhead: number;
        renderedWindowsBehind: number;
    };
    // (undocumented)
    forceUpdate(): void;
    // (undocumented)
    static getDerivedStateFromProps<T = any>(nextProps: IListProps<T>, previousState: IListState<T>): IListState<T>;
    // (undocumented)
    getStartItemIndexInView(measureItem?: (itemIndex: number) => number): number;
    getTotalListHeight(): number;
    // (undocumented)
    readonly pageRefs: Readonly<Record<string, unknown>>;
    // (undocumented)
    render(): JSX.Element | null;
    scrollToIndex(index: number, measureItem?: (itemIndex: number) => number, scrollToMode?: ScrollToMode): void;
    // (undocumented)
    shouldComponentUpdate(newProps: IListProps<T>, newState: IListState<T>): boolean;
    }

// @public (undocumented)
export const ListPeoplePicker: React.FunctionComponent<IPeoplePickerProps>;

// @public
export class ListPeoplePickerBase extends MemberListPeoplePicker {
    static defaultProps: {
        onRenderItem: (props: IPeoplePickerItemSelectedProps) => JSX.Element;
        onRenderSuggestionsItem: (personaProps: IPersonaProps, suggestionsProps?: IBasePickerSuggestionsProps<any> | undefined) => JSX.Element;
        createGenericItem: typeof createGenericItem;
    };
}

// @public (undocumented)
export const MarqueeSelection: React.FunctionComponent<IMarqueeSelectionProps>;

// @public (undocumented)
export const MaskedTextField: React.FunctionComponent<IMaskedTextFieldProps>;

// @public (undocumented)
export const MAX_COLOR_ALPHA = 100;

// @public (undocumented)
export const MAX_COLOR_HUE = 359;

// @public (undocumented)
export const MAX_COLOR_RGB = 255;

// @public @deprecated (undocumented)
export const MAX_COLOR_RGBA = 255;

// @public (undocumented)
export const MAX_COLOR_SATURATION = 100;

// @public (undocumented)
export const MAX_COLOR_VALUE = 100;

// @public
export const MAX_HEX_LENGTH = 6;

// @public
export const MAX_RGBA_LENGTH = 3;

// @public (undocumented)
export const MeasuredContext: React.Context<{
    isMeasured: boolean;
}>;

// @public (undocumented)
export class MemberListPeoplePicker extends BasePickerListBelow<IPersonaProps, IPeoplePickerProps> {
}

// @public
export function mergeOverflows(keySequences: string[], overflowKeySequences: string[]): string[];

// @public (undocumented)
export const MessageBar: React.FunctionComponent<IMessageBarProps>;

// @public (undocumented)
export const MessageBarBase: React.FunctionComponent<IMessageBarProps>;

// @public (undocumented)
export class MessageBarButton extends React.Component<IButtonProps, {}> {
    // (undocumented)
    render(): JSX.Element;
}

// @public (undocumented)
export enum MessageBarType {
    blocked = 2,
    error = 1,
    info = 0,
    severeWarning = 3,
    success = 4,
    warning = 5
}

// @public
export const MIN_HEX_LENGTH = 3;

// @public
export const MIN_RGBA_LENGTH = 1;

// @public (undocumented)
export const Modal: React.FunctionComponent<IModalProps>;

// @public (undocumented)
export class ModalBase extends React.Component<IModalProps, IDialogState> implements IModal {
    constructor(props: IModalProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentDidUpdate(prevProps: IModalProps, prevState: IDialogState): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    static defaultProps: IModalProps;
    // (undocumented)
    focus(): void;
    // (undocumented)
    render(): JSX.Element | null;
    // (undocumented)
    UNSAFE_componentWillReceiveProps(newProps: IModalProps): void;
}

// @public (undocumented)
export const Nav: React.FunctionComponent<INavProps>;

// @public (undocumented)
export class NavBase extends React.Component<INavProps, INavState> implements INav {
    constructor(props: INavProps);
    // (undocumented)
    static defaultProps: INavProps;
    focus(forceIntoFirstElement?: boolean): boolean;
    // (undocumented)
    render(): JSX.Element | null;
    // (undocumented)
    readonly selectedKey: string | undefined;
    }

// @public (undocumented)
export const NormalPeoplePicker: React.FunctionComponent<IPeoplePickerProps>;

// @public
export class NormalPeoplePickerBase extends BasePeoplePicker {
    static defaultProps: {
        onRenderItem: (props: IPeoplePickerItemSelectedProps) => JSX.Element;
        onRenderSuggestionsItem: (personaProps: IPersonaProps, suggestionsProps?: IBasePickerSuggestionsProps<any> | undefined) => JSX.Element;
        createGenericItem: typeof createGenericItem;
    };
}

// @public @deprecated (undocumented)
export type OnChangeCallback = IChoiceGroupOptionProps['onChange'];

// @public @deprecated (undocumented)
export type OnFocusCallback = IChoiceGroupOptionProps['onFocus'];

// @public (undocumented)
export enum OpenCardMode {
    hotKey = 1,
    hover = 0
}

// @public (undocumented)
export enum OverflowButtonType {
    descriptive = 1,
    downArrow = 3,
    more = 2,
    none = 0
}

// @public (undocumented)
export const OverflowSet: React.FunctionComponent<IOverflowSetProps>;

// @public (undocumented)
export class OverflowSetBase extends React.Component<IOverflowSetProps, {}> implements IOverflowSet {
    constructor(props: IOverflowSetProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentDidUpdate(): void;
    // (undocumented)
    componentWillUnmount(): void;
    focus(forceIntoFirstElement?: boolean): boolean;
    focusElement(childElement?: HTMLElement): boolean;
    // (undocumented)
    render(): JSX.Element;
    // (undocumented)
    UNSAFE_componentWillUpdate(): void;
}

// @public (undocumented)
export const Overlay: React.FunctionComponent<IOverlayProps>;

// @public (undocumented)
export class OverlayBase extends React.Component<IOverlayProps, {}> {
    constructor(props: IOverlayProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    render(): JSX.Element;
}

// @public
export const Panel: React.FunctionComponent<IPanelProps>;

// @public (undocumented)
export enum PanelType {
    custom = 7,
    customNear = 8,
    extraLarge = 6,
    large = 4,
    largeFixed = 5,
    medium = 3,
    smallFixedFar = 1,
    smallFixedNear = 2,
    smallFluid = 0
}

// @public (undocumented)
export const PeoplePickerItem: React.FunctionComponent<IPeoplePickerItemSelectedProps>;

// @public (undocumented)
export const PeoplePickerItemBase: (props: IPeoplePickerItemSelectedProps) => JSX.Element;

// @public (undocumented)
export const PeoplePickerItemSuggestion: React.FunctionComponent<IPeoplePickerItemSuggestionProps>;

// @public (undocumented)
export const PeoplePickerItemSuggestionBase: (props: IPeoplePickerItemSuggestionProps) => JSX.Element;

// @public
export const Persona: React.FunctionComponent<IPersonaProps>;

// @public
export const PersonaBase: React.FunctionComponent<IPersonaProps>;

// @public
export const PersonaCoin: React.FunctionComponent<IPersonaCoinProps>;

// @public
export const PersonaCoinBase: React.FunctionComponent<IPersonaCoinProps>;

// @public (undocumented)
export enum PersonaInitialsColor {
    // @deprecated
    black = 11,
    // (undocumented)
    blue = 1,
    // (undocumented)
    burgundy = 19,
    // (undocumented)
    coolGray = 21,
    // (undocumented)
    cyan = 23,
    // (undocumented)
    darkBlue = 2,
    // (undocumented)
    darkGreen = 6,
    // (undocumented)
    darkRed = 14,
    // (undocumented)
    gold = 18,
    gray = 22,
    // (undocumented)
    green = 5,
    // (undocumented)
    lightBlue = 0,
    // (undocumented)
    lightGreen = 4,
    // (undocumented)
    lightPink = 7,
    // (undocumented)
    lightRed = 17,
    // (undocumented)
    magenta = 9,
    // (undocumented)
    orange = 12,
    // (undocumented)
    pink = 8,
    // (undocumented)
    purple = 10,
    // @deprecated
    red = 13,
    // (undocumented)
    rust = 24,
    // (undocumented)
    teal = 3,
    transparent = 15,
    // (undocumented)
    violet = 16,
    // (undocumented)
    warmGray = 20
}

// @public (undocumented)
export enum PersonaPresence {
    // (undocumented)
    away = 3,
    // (undocumented)
    blocked = 5,
    // (undocumented)
    busy = 6,
    // (undocumented)
    dnd = 4,
    // (undocumented)
    none = 0,
    // (undocumented)
    offline = 1,
    // (undocumented)
    online = 2
}

// @public (undocumented)
export namespace personaPresenceSize {
    const // (undocumented)
    size6 = "6px";
    const // (undocumented)
    size8 = "8px";
    const // (undocumented)
    size12 = "12px";
    const // (undocumented)
    size16 = "16px";
    const // (undocumented)
    size20 = "20px";
    const // (undocumented)
    size28 = "28px";
    const // (undocumented)
    size32 = "32px";
    const // @deprecated (undocumented)
    border = "2px";
}

// @public (undocumented)
export enum PersonaSize {
    // @deprecated
    extraExtraSmall = 1,
    // @deprecated
    extraLarge = 6,
    // @deprecated
    extraSmall = 2,
    // @deprecated
    large = 5,
    // @deprecated
    regular = 4,
    // @deprecated
    size10 = 9,
    size100 = 15,
    size120 = 18,
    // @deprecated
    size16 = 8,
    size24 = 10,
    // @deprecated
    size28 = 7,
    size32 = 11,
    size40 = 12,
    size48 = 13,
    size56 = 16,
    size72 = 14,
    size8 = 17,
    // @deprecated
    small = 3,
    // @deprecated
    tiny = 0
}

// @public (undocumented)
export namespace personaSize {
    const // (undocumented)
    size8 = "20px";
    const // (undocumented)
    size10 = "20px";
    const // (undocumented)
    size16 = "16px";
    const // (undocumented)
    size24 = "24px";
    const // (undocumented)
    size28 = "28px";
    const // (undocumented)
    size32 = "32px";
    const // (undocumented)
    size40 = "40px";
    const // (undocumented)
    size48 = "48px";
    const // (undocumented)
    size56 = "56px";
    const // (undocumented)
    size72 = "72px";
    const // (undocumented)
    size100 = "100px";
    const // (undocumented)
    size120 = "120px";
}

// @public (undocumented)
export const PlainCard: React.FunctionComponent<IPlainCardProps>;

// @public (undocumented)
export class PlainCardBase extends React.Component<IPlainCardProps, {}> {
    constructor(props: IPlainCardProps);
    // (undocumented)
    render(): JSX.Element;
}

export { Point }

// @public
export class Popup extends React.Component<IPopupProps, IPopupState> {
    constructor(props: IPopupProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentDidUpdate(): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    static defaultProps: IPopupProps;
    // (undocumented)
    render(): JSX.Element;
    // (undocumented)
    _root: React.RefObject<HTMLDivElement>;
    // (undocumented)
    UNSAFE_componentWillMount(): void;
    }

// @public (undocumented)
export enum Position {
    // (undocumented)
    bottom = 1,
    // (undocumented)
    end = 3,
    // (undocumented)
    start = 2,
    // (undocumented)
    top = 0
}

// @public (undocumented)
export function positionCallout(props: IPositionProps, hostElement: HTMLElement, elementToPosition: HTMLElement, previousPositions?: ICalloutPositionedInfo): ICalloutPositionedInfo;

// @public (undocumented)
export function positionCard(props: IPositionProps, hostElement: HTMLElement, elementToPosition: HTMLElement, previousPositions?: ICalloutPositionedInfo): ICalloutPositionedInfo;

// @public
export function positionElement(props: IPositionProps, hostElement: HTMLElement, elementToPosition: HTMLElement, previousPositions?: IPositionedData): IPositionedData;

// @public (undocumented)
export const PositioningContainer: React.FunctionComponent<IPositioningContainerProps>;

// @public (undocumented)
export const presenceBoolean: (presence: PersonaPresence) => {
    isAvailable: boolean;
    isAway: boolean;
    isBlocked: boolean;
    isBusy: boolean;
    isDoNotDisturb: boolean;
    isOffline: boolean;
};

// @public (undocumented)
export class PrimaryButton extends React.Component<IButtonProps, {}> {
    // (undocumented)
    render(): JSX.Element;
}

// @public
export const ProgressIndicator: React.FunctionComponent<IProgressIndicatorProps>;

// @public
export class ProgressIndicatorBase extends React.Component<IProgressIndicatorProps, {}> {
    // (undocumented)
    static defaultProps: {
        label: string;
        description: string;
        width: number;
    };
    // (undocumented)
    render(): JSX.Element;
}

// @public (undocumented)
export const Rating: React.FunctionComponent<IRatingProps>;

// @public (undocumented)
export const RatingBase: React.FunctionComponent<IRatingProps>;

// @public (undocumented)
export enum RatingSize {
    // (undocumented)
    Large = 1,
    // (undocumented)
    Small = 0
}

// @public (undocumented)
export enum RectangleEdge {
    // (undocumented)
    bottom = -1,
    // (undocumented)
    left = 2,
    // (undocumented)
    right = -2,
    // (undocumented)
    top = 1
}

// @public (undocumented)
export const ResizeGroup: typeof ResizeGroupBase;

// @public (undocumented)
export class ResizeGroupBase extends React.Component<IResizeGroupProps, IResizeGroupState> {
    constructor(props: IResizeGroupProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentDidUpdate(prevProps: IResizeGroupProps): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    remeasure(): void;
    // (undocumented)
    render(): JSX.Element;
    // (undocumented)
    UNSAFE_componentWillReceiveProps(nextProps: IResizeGroupProps): void;
    }

// @public (undocumented)
export enum ResizeGroupDirection {
    // (undocumented)
    horizontal = 0,
    // (undocumented)
    vertical = 1
}

// @public (undocumented)
export enum ResponsiveMode {
    // (undocumented)
    large = 2,
    // (undocumented)
    medium = 1,
    // (undocumented)
    small = 0,
    // (undocumented)
    unknown = 999,
    // (undocumented)
    xLarge = 3,
    // (undocumented)
    xxLarge = 4,
    // (undocumented)
    xxxLarge = 5
}

// @public
export function rgb2hex(r: number, g: number, b: number): string;

// @public
export function rgb2hsv(r: number, g: number, b: number): IHSV;

// @public
export const RGBA_REGEX: RegExp;

// @public (undocumented)
export const ScrollablePane: React.FunctionComponent<IScrollablePaneProps>;

// @public (undocumented)
export class ScrollablePaneBase extends React.Component<IScrollablePaneProps, IScrollablePaneState> implements IScrollablePane {
    constructor(props: IScrollablePaneProps);
    // (undocumented)
    addSticky: (sticky: Sticky) => void;
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentDidUpdate(prevProps: IScrollablePaneProps, prevState: IScrollablePaneState): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    readonly contentContainer: HTMLDivElement | null;
    // (undocumented)
    forceLayoutUpdate(): void;
    // (undocumented)
    getScrollPosition: () => number;
    // (undocumented)
    notifySubscribers: () => void;
    // (undocumented)
    removeSticky: (sticky: Sticky) => void;
    // (undocumented)
    render(): JSX.Element;
    // (undocumented)
    readonly root: HTMLDivElement | null;
    // (undocumented)
    setStickiesDistanceFromTop(): void;
    // (undocumented)
    shouldComponentUpdate(nextProps: IScrollablePaneProps, nextState: IScrollablePaneState): boolean;
    // (undocumented)
    sortSticky: (sticky: Sticky, sortAgain?: boolean | undefined) => void;
    // (undocumented)
    readonly stickyAbove: HTMLDivElement | null;
    // (undocumented)
    readonly stickyBelow: HTMLDivElement | null;
    // (undocumented)
    subscribe: (handler: Function) => void;
    // (undocumented)
    syncScrollSticky: (sticky: Sticky) => void;
    // (undocumented)
    unsubscribe: (handler: Function) => void;
    // (undocumented)
    updateStickyRefHeights: () => void;
}

// @public (undocumented)
export const ScrollablePaneContext: React.Context<IScrollablePaneContext>;

// @public (undocumented)
export const ScrollbarVisibility: {
    auto: "auto";
    always: "always";
};

// @public (undocumented)
export type ScrollbarVisibility = typeof ScrollbarVisibility[keyof typeof ScrollbarVisibility];

// @public (undocumented)
export const ScrollToMode: {
    auto: 0;
    top: 1;
    bottom: 2;
    center: 3;
};

// @public (undocumented)
export type ScrollToMode = typeof ScrollToMode[keyof typeof ScrollToMode];

// @public (undocumented)
export const SearchBox: React.FunctionComponent<ISearchBoxProps>;

// @public (undocumented)
export class SearchBoxBase extends React.Component<ISearchBoxProps, ISearchBoxState> {
    constructor(props: ISearchBoxProps);
    // (undocumented)
    static defaultProps: Pick<ISearchBoxProps, 'disableAnimation' | 'clearButtonProps'>;
    focus(): void;
    hasFocus(): boolean;
    // (undocumented)
    render(): JSX.Element;
    // (undocumented)
    UNSAFE_componentWillReceiveProps(newProps: ISearchBoxProps): void;
}

// @public (undocumented)
export enum SelectableOptionMenuItemType {
    // (undocumented)
    Divider = 1,
    // (undocumented)
    Header = 2,
    // (undocumented)
    Normal = 0
}

// @public
export class SelectedPeopleList extends BasePeopleSelectedItemsList {
    // (undocumented)
    static defaultProps: any;
    // (undocumented)
    protected renderItems: () => JSX.Element[];
}

export { Selection }

export { SELECTION_CHANGE }

export { SelectionDirection }

export { SelectionMode }

// @public (undocumented)
export class SelectionZone extends React.Component<ISelectionZoneProps, ISelectionZoneState> {
    constructor(props: ISelectionZoneProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentDidUpdate(previousProps: ISelectionZoneProps): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    static defaultProps: {
        isSelectedOnFocus: boolean;
        selectionMode: SelectionMode;
    };
    // (undocumented)
    static getDerivedStateFromProps(nextProps: ISelectionZoneProps, prevState: ISelectionZoneState): ISelectionZoneState;
    ignoreNextFocus: () => void;
    // (undocumented)
    render(): JSX.Element;
    }

// @public (undocumented)
export enum SemanticColorSlots {
    // (undocumented)
    bodyBackground = 0,
    // (undocumented)
    bodyText = 1,
    // (undocumented)
    disabledBackground = 2,
    // (undocumented)
    disabledText = 3
}

// @public (undocumented)
export const Separator: React.FunctionComponent<ISeparatorProps>;

// @public (undocumented)
export const SeparatorBase: React.FunctionComponent<ISeparatorProps>;

// @public
export function sequencesToID(keySequences: string[]): string;

// @public
export enum Shade {
    // (undocumented)
    Shade1 = 1,
    // (undocumented)
    Shade2 = 2,
    // (undocumented)
    Shade3 = 3,
    // (undocumented)
    Shade4 = 4,
    // (undocumented)
    Shade5 = 5,
    // (undocumented)
    Shade6 = 6,
    // (undocumented)
    Shade7 = 7,
    // (undocumented)
    Shade8 = 8,
    // (undocumented)
    Unshaded = 0
}

// @public (undocumented)
export const Shimmer: React.FunctionComponent<IShimmerProps>;

// @public (undocumented)
export class ShimmerBase extends React.Component<IShimmerProps, IShimmerState> {
    constructor(props: IShimmerProps);
    // (undocumented)
    componentDidUpdate(prevProps: IShimmerProps): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    static defaultProps: IShimmerProps;
    // (undocumented)
    render(): JSX.Element;
}

// @public (undocumented)
export const ShimmerCircle: React.FunctionComponent<IShimmerCircleProps>;

// @public (undocumented)
export const ShimmerCircleBase: React.FunctionComponent<IShimmerCircleProps>;

// @public
export enum ShimmerElementsDefaultHeights {
    circle = 24,
    gap = 16,
    line = 16
}

// @public (undocumented)
export const ShimmerElementsGroup: React.FunctionComponent<IShimmerElementsGroupProps>;

// @public (undocumented)
export const ShimmerElementsGroupBase: React.FunctionComponent<IShimmerElementsGroupProps>;

// @public
export enum ShimmerElementType {
    circle = 2,
    gap = 3,
    line = 1
}

// @public (undocumented)
export const ShimmerGap: React.FunctionComponent<IShimmerGapProps>;

// @public (undocumented)
export const ShimmerGapBase: React.FunctionComponent<IShimmerGapProps>;

// @public (undocumented)
export const ShimmerLine: React.FunctionComponent<IShimmerLineProps>;

// @public (undocumented)
export const ShimmerLineBase: React.FunctionComponent<IShimmerLineProps>;

// @public (undocumented)
export const sizeBoolean: (size: PersonaSize) => {
    isSize8: boolean;
    isSize10: boolean;
    isSize16: boolean;
    isSize24: boolean;
    isSize28: boolean;
    isSize32: boolean;
    isSize40: boolean;
    isSize48: boolean;
    isSize56: boolean;
    isSize72: boolean;
    isSize100: boolean;
    isSize120: boolean;
};

// @public (undocumented)
export const sizeToPixels: {
    [key: number]: number;
};

// @public (undocumented)
export class SpinButton extends React.Component<ISpinButtonProps, ISpinButtonState> implements ISpinButton {
    constructor(props: ISpinButtonProps);
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    static defaultProps: DefaultProps;
    // (undocumented)
    focus(): void;
    // (undocumented)
    render(): JSX.Element;
    UNSAFE_componentWillReceiveProps(newProps: ISpinButtonProps): void;
    readonly value: string | undefined;
    }

// @public (undocumented)
export const Spinner: React.FunctionComponent<ISpinnerProps>;

// @public (undocumented)
export class SpinnerBase extends React.Component<ISpinnerProps, any> {
    // (undocumented)
    static defaultProps: ISpinnerProps;
    // (undocumented)
    render(): JSX.Element;
}

// @public
export type SpinnerLabelPosition = 'top' | 'right' | 'bottom' | 'left';

// @public
export enum SpinnerSize {
    large = 3,
    medium = 2,
    small = 1,
    xSmall = 0
}

// @public @deprecated
export enum SpinnerType {
    // @deprecated
    large = 1,
    // @deprecated
    normal = 0
}

// @public (undocumented)
export const Stack: React.FunctionComponent<IStackProps> & {
    Item: React.FunctionComponent<IStackItemProps>;
};

// @public (undocumented)
export const StackItem: React.FunctionComponent<IStackItemProps>;

// @public (undocumented)
export class Sticky extends React.Component<IStickyProps, IStickyState> {
    constructor(props: IStickyProps);
    // (undocumented)
    addSticky(stickyContent: HTMLDivElement): void;
    // (undocumented)
    readonly canStickyBottom: boolean;
    // (undocumented)
    readonly canStickyTop: boolean;
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentDidUpdate(prevProps: IStickyProps, prevState: IStickyState): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    static contextType: React.Context<IScrollablePaneContext>;
    // (undocumented)
    static defaultProps: IStickyProps;
    // (undocumented)
    readonly nonStickyContent: HTMLDivElement | null;
    // (undocumented)
    readonly placeholder: HTMLDivElement | null;
    // (undocumented)
    render(): JSX.Element;
    // (undocumented)
    resetSticky(): void;
    // (undocumented)
    readonly root: HTMLDivElement | null;
    // (undocumented)
    setDistanceFromTop(container: HTMLDivElement): void;
    // (undocumented)
    shouldComponentUpdate(nextProps: IStickyProps, nextState: IStickyState): boolean;
    // (undocumented)
    readonly stickyContentBottom: HTMLDivElement | null;
    // (undocumented)
    readonly stickyContentTop: HTMLDivElement | null;
    // (undocumented)
    syncScroll: (container: HTMLElement) => void;
}

// @public (undocumented)
export enum StickyPositionType {
    // (undocumented)
    Both = 0,
    // (undocumented)
    Footer = 2,
    // (undocumented)
    Header = 1
}

// @public
export enum SuggestionActionType {
    forceResolve = 1,
    none = 0,
    searchMore = 2
}

// @public (undocumented)
export enum SuggestionItemType {
    // (undocumented)
    footer = 2,
    // (undocumented)
    header = 0,
    // (undocumented)
    suggestion = 1
}

// @public (undocumented)
export class Suggestions<T> extends React.Component<ISuggestionsProps<T>, ISuggestionsState> {
    constructor(suggestionsProps: ISuggestionsProps<T>);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentDidUpdate(): void;
    // (undocumented)
    executeSelectedAction(): void;
    // (undocumented)
    focusAboveSuggestions(): void;
    // (undocumented)
    focusBelowSuggestions(): void;
    // (undocumented)
    focusSearchForMoreButton(): void;
    // (undocumented)
    protected _forceResolveButton: React.RefObject<IButton>;
    // (undocumented)
    hasSuggestedAction(): boolean;
    // (undocumented)
    hasSuggestedActionSelected(): boolean;
    // (undocumented)
    render(): JSX.Element;
    // (undocumented)
    scrollSelected(): void;
    // (undocumented)
    protected _searchForMoreButton: React.RefObject<IButton>;
    // (undocumented)
    protected _selectedElement: React.RefObject<HTMLDivElement>;
    tryHandleKeyDown: (keyCode: number, currentSuggestionIndex: number) => boolean;
}

// @public
export class SuggestionsControl<T> extends React.Component<ISuggestionsControlProps<T>, ISuggestionsControlState<T>> {
    constructor(suggestionsProps: ISuggestionsControlProps<T>);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentDidUpdate(): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    readonly currentSuggestion: ISuggestionModel<T> | undefined;
    // (undocumented)
    readonly currentSuggestionIndex: number;
    // (undocumented)
    executeSelectedAction(): void;
    // (undocumented)
    protected _forceResolveButton: IButton;
    handleKeyDown(keyCode: number): boolean;
    // (undocumented)
    hasSelection(): boolean;
    // (undocumented)
    hasSuggestionSelected(): boolean;
    // (undocumented)
    removeSuggestion(index?: number): void;
    // (undocumented)
    render(): JSX.Element;
    // (undocumented)
    protected renderFooterItems(): JSX.Element | null;
    // (undocumented)
    protected renderHeaderItems(): JSX.Element | null;
    // (undocumented)
    protected _renderSuggestions(): JSX.Element;
    protected resetSelectedItem(): void;
    // (undocumented)
    scrollSelected(): void;
    // (undocumented)
    protected _searchForMoreButton: IButton;
    // (undocumented)
    readonly selectedElement: HTMLDivElement | undefined;
    // (undocumented)
    protected _selectedElement: React.RefObject<HTMLDivElement>;
    protected selectFirstItem(): void;
    protected selectLastItem(): void;
    protected selectNextItem(itemType: SuggestionItemType, originalItemType?: SuggestionItemType): void;
    protected selectPreviousItem(itemType: SuggestionItemType, originalItemType?: SuggestionItemType): void;
    // (undocumented)
    protected _suggestions: React.RefObject<SuggestionsCore<T>>;
    // (undocumented)
    UNSAFE_componentWillReceiveProps(newProps: ISuggestionsControlProps<T>): void;
}

// @public (undocumented)
export class SuggestionsController<T> {
    constructor();
    // (undocumented)
    convertSuggestionsToSuggestionItems(suggestions: Array<ISuggestionModel<T> | T>): ISuggestionModel<T>[];
    // (undocumented)
    createGenericSuggestion(itemToConvert: ISuggestionModel<T> | T): void;
    // (undocumented)
    currentIndex: number;
    // (undocumented)
    currentSuggestion: ISuggestionModel<T> | undefined;
    // (undocumented)
    deselectAllSuggestions(): void;
    // (undocumented)
    getCurrentItem(): ISuggestionModel<T>;
    // (undocumented)
    getSuggestionAtIndex(index: number): ISuggestionModel<T>;
    // (undocumented)
    getSuggestions(): ISuggestionModel<T>[];
    // (undocumented)
    hasSelectedSuggestion(): boolean;
    nextSuggestion(): boolean;
    previousSuggestion(): boolean;
    // (undocumented)
    removeSuggestion(index: number): void;
    // (undocumented)
    setSelectedSuggestion(index: number): void;
    // (undocumented)
    suggestions: ISuggestionModel<T>[];
    // (undocumented)
    updateSuggestions(newSuggestions: T[], selectedIndex?: number): void;
}

// @public
export class SuggestionsCore<T> extends React.Component<ISuggestionsCoreProps<T>, {}> {
    constructor(suggestionsProps: ISuggestionsCoreProps<T>);
    // (undocumented)
    componentDidUpdate(): void;
    // (undocumented)
    currentIndex: number;
    // (undocumented)
    currentSuggestion: ISuggestionModel<T> | undefined;
    // (undocumented)
    deselectAllSuggestions(): void;
    // (undocumented)
    getCurrentItem(): ISuggestionModel<T>;
    // (undocumented)
    getSuggestionAtIndex(index: number): ISuggestionModel<T>;
    // (undocumented)
    hasSuggestionSelected(): boolean;
    nextSuggestion(): boolean;
    previousSuggestion(): boolean;
    // (undocumented)
    removeSuggestion(index: number): void;
    // (undocumented)
    render(): JSX.Element;
    // (undocumented)
    scrollSelected(): void;
    // (undocumented)
    readonly selectedElement: HTMLDivElement | undefined;
    // (undocumented)
    protected _selectedElement: React.RefObject<HTMLDivElement>;
    // (undocumented)
    setSelectedSuggestion(index: number): void;
    }

// @public (undocumented)
export class SuggestionsHeaderFooterItem extends React.Component<ISuggestionsHeaderFooterItemProps, {}> {
    constructor(props: ISuggestionsHeaderFooterItemProps);
    // (undocumented)
    render(): JSX.Element;
}

// @public (undocumented)
export class SuggestionsItem<T> extends React.Component<ISuggestionItemProps<T>, {}> {
    constructor(props: ISuggestionItemProps<T>);
    // (undocumented)
    render(): JSX.Element;
}

// @public (undocumented)
export class SuggestionsStore<T> {
    constructor(options?: SuggestionsStoreOptions<T>);
    // (undocumented)
    convertSuggestionsToSuggestionItems(suggestions: Array<ISuggestionModel<T> | T>): ISuggestionModel<T>[];
    // (undocumented)
    getSuggestionAtIndex(index: number): ISuggestionModel<T>;
    // (undocumented)
    getSuggestions(): ISuggestionModel<T>[];
    // (undocumented)
    removeSuggestion(index: number): void;
    // (undocumented)
    suggestions: ISuggestionModel<T>[];
    // (undocumented)
    updateSuggestions(newSuggestions: T[]): void;
}

// @public (undocumented)
export type SuggestionsStoreOptions<T> = {
    getAriaLabel?: (item: T) => string;
};

// @public (undocumented)
export const SwatchColorPicker: React.FunctionComponent<ISwatchColorPickerProps>;

// @public (undocumented)
export const SwatchColorPickerBase: React.FunctionComponent<ISwatchColorPickerProps>;

// @public (undocumented)
export const TagItem: React.FunctionComponent<ITagItemProps>;

// @public (undocumented)
export const TagItemBase: (props: ITagItemProps) => JSX.Element;

// @public (undocumented)
export const TagItemSuggestion: React.FunctionComponent<ITagItemSuggestionProps>;

// @public (undocumented)
export const TagItemSuggestionBase: (props: ITagItemSuggestionProps) => JSX.Element;

// @public (undocumented)
export const TagPicker: React.FunctionComponent<ITagPickerProps>;

// @public (undocumented)
export class TagPickerBase extends BasePicker<ITag, ITagPickerProps> {
    constructor(props: ITagPickerProps);
    // (undocumented)
    static defaultProps: {
        onRenderItem: (props: ITagItemProps) => JSX.Element;
        onRenderSuggestionsItem: (props: ITag) => JSX.Element;
    };
}

export { Target }

// @public (undocumented)
export const TeachingBubble: React.FunctionComponent<ITeachingBubbleProps>;

// @public (undocumented)
export class TeachingBubbleBase extends React.Component<ITeachingBubbleProps, ITeachingBubbleState> {
    constructor(props: ITeachingBubbleProps);
    // (undocumented)
    static defaultProps: {
        calloutProps: {
            beakWidth: number;
            gapSpace: number;
            setInitialFocus: boolean;
            doNotLayer: boolean;
            directionalHint: 12;
        };
    };
    // (undocumented)
    focus(): void;
    // (undocumented)
    render(): JSX.Element;
    // (undocumented)
    rootElement: React.RefObject<HTMLDivElement>;
}

// @public (undocumented)
export const TeachingBubbleContent: React.FunctionComponent<ITeachingBubbleProps>;

// @public (undocumented)
export class TeachingBubbleContentBase extends React.Component<ITeachingBubbleProps, ITeachingBubbleState> {
    constructor(props: ITeachingBubbleProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    focus(): void;
    // (undocumented)
    render(): JSX.Element;
    // (undocumented)
    rootElement: React.RefObject<HTMLDivElement>;
}

// @public (undocumented)
export const Text: React.FunctionComponent<ITextProps>;

// @public (undocumented)
export const TextField: React.FunctionComponent<ITextFieldProps>;

// Warning: (ae-incompatible-release-tags) The symbol "TextFieldBase" is marked as @public, but its signature references "ITextFieldState" which is marked as @internal
// Warning: (ae-incompatible-release-tags) The symbol "TextFieldBase" is marked as @public, but its signature references "ITextFieldSnapshot" which is marked as @internal
//
// @public (undocumented)
export class TextFieldBase extends React.Component<ITextFieldProps, ITextFieldState, ITextFieldSnapshot> implements ITextField {
    constructor(props: ITextFieldProps);
    blur(): void;
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentDidUpdate(prevProps: ITextFieldProps, prevState: ITextFieldState, snapshot: ITextFieldSnapshot): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    static defaultProps: ITextFieldProps;
    focus(): void;
    // (undocumented)
    getSnapshotBeforeUpdate(prevProps: ITextFieldProps, prevState: ITextFieldState): ITextFieldSnapshot | null;
    // (undocumented)
    render(): JSX.Element;
    select(): void;
    readonly selectionEnd: number | null;
    readonly selectionStart: number | null;
    setSelectionEnd(value: number): void;
    setSelectionRange(start: number, end: number): void;
    setSelectionStart(value: number): void;
    readonly value: string | undefined;
    }

// @public (undocumented)
export const TextStyles: ITextComponent['styles'];

// @public (undocumented)
export const TextView: ITextComponent['view'];

// @public (undocumented)
export class ThemeGenerator {
    static getThemeAsCode(slotRules: IThemeRules): any;
    static getThemeAsCodeWithCreateTheme(slotRules: IThemeRules): any;
    static getThemeAsJson(slotRules: IThemeRules): any;
    static getThemeAsSass(slotRules: IThemeRules): any;
    static getThemeForPowerShell(slotRules: IThemeRules): any;
    static insureSlots(slotRules: IThemeRules, isInverted: boolean): void;
    static setSlot(rule: IThemeSlotRule, color: string | IColor, isInverted?: boolean, isCustomization?: boolean, overwriteCustomColor?: boolean): void;
    }

// @public (undocumented)
export function themeRulesStandardCreator(): IThemeRules;

// @public (undocumented)
export const Tooltip: React.FunctionComponent<ITooltipProps>;

// @public (undocumented)
export class TooltipBase extends React.Component<ITooltipProps, any> {
    // (undocumented)
    static defaultProps: Partial<ITooltipProps>;
    // (undocumented)
    render(): JSX.Element;
}

// @public (undocumented)
export enum TooltipDelay {
    long = 2,
    medium = 1,
    // (undocumented)
    zero = 0
}

// @public (undocumented)
export const TooltipHost: React.FunctionComponent<ITooltipHostProps>;

// @public (undocumented)
export class TooltipHostBase extends React.Component<ITooltipHostProps, ITooltipHostState> implements ITooltipHost {
    constructor(props: ITooltipHostProps);
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    static defaultProps: {
        delay: TooltipDelay;
    };
    // (undocumented)
    dismiss: () => void;
    // (undocumented)
    render(): JSX.Element;
    // (undocumented)
    show: () => void;
    }

// @public (undocumented)
export enum TooltipOverflowMode {
    Parent = 0,
    Self = 1
}

// @public
export function transitionKeysAreEqual(key1: IKeytipTransitionKey, key2: IKeytipTransitionKey): boolean;

// @public
export function transitionKeysContain(keys: IKeytipTransitionKey[], key: IKeytipTransitionKey): boolean;

// @public
export function updateA(color: IColor, a: number): IColor;

// @public
export function updateH(color: IColor, h: number): IColor;

// @public
export function updateRGB(color: IColor, component: keyof IRGB, value: number): IColor;

// @public
export function updateSV(color: IColor, s: number, v: number): IColor;

// @public
export function updateT(color: IColor, t: number): IColor;

// @public (undocumented)
export function useHeightOffset({ finalHeight }: IPositioningContainerProps, contentHost: React.RefObject<HTMLDivElement | null>): number;

// @public
export function useKeytipRef<TElement extends HTMLElement = HTMLElement>(options: KeytipDataOptions): React.Ref<TElement>;

// @public
export enum ValidationState {
    invalid = 2,
    valid = 0,
    warning = 1
}

// @public (undocumented)
export const VerticalDivider: React.FunctionComponent<IVerticalDividerProps>;


export * from "@fluentui/react-focus";
export * from "@uifabric/icons";
export * from "@uifabric/styling";
export * from "@uifabric/utilities";

// Warnings were encountered during analysis:
//
// lib/components/ColorPicker/ColorPicker.base.d.ts:11:9 - (ae-forgotten-export) The symbol "ColorComponent" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
