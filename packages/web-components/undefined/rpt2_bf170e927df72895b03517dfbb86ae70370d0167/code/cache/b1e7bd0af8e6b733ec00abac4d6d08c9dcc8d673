{"code":"import { clamp, ColorHSL, ColorLAB, ColorRGBA64, hslToRGB, interpolateRGB, labToRGB, rgbToHSL, rgbToLAB, roundToPrecisionSmall, } from '@microsoft/fast-colors';\r\nimport { isSwatchRGB, SwatchRGB } from './swatch';\r\nimport { binarySearch } from './utilities/binary-search';\r\nimport { directionByIsDark } from './utilities/direction-by-is-dark';\r\nimport { contrast } from './utilities/relative-luminance';\r\nconst defaultPaletteRGBOptions = {\r\n    stepContrast: 1.03,\r\n    stepContrastRamp: 0.03,\r\n    preserveSource: false,\r\n};\r\nfunction create(rOrSource, g, b) {\r\n    if (typeof rOrSource === 'number') {\r\n        return PaletteRGB.from(SwatchRGB.create(rOrSource, g, b));\r\n    }\r\n    else {\r\n        return PaletteRGB.from(rOrSource);\r\n    }\r\n}\r\nfunction from(source, options) {\r\n    return isSwatchRGB(source)\r\n        ? PaletteRGBImpl.from(source, options)\r\n        : PaletteRGBImpl.from(SwatchRGB.create(source.r, source.g, source.b), options);\r\n}\r\n/** @public */\r\nexport const PaletteRGB = Object.freeze({\r\n    create,\r\n    from,\r\n});\r\n/**\r\n * A {@link Palette} representing RGB swatch values.\r\n * @public\r\n */\r\nclass PaletteRGBImpl {\r\n    /**\r\n     *\r\n     * @param source - The source color for the palette\r\n     * @param swatches - All swatches in the palette\r\n     */\r\n    constructor(source, swatches) {\r\n        this.closestIndexCache = new Map();\r\n        this.source = source;\r\n        this.swatches = swatches;\r\n        this.reversedSwatches = Object.freeze([...this.swatches].reverse());\r\n        this.lastIndex = this.swatches.length - 1;\r\n    }\r\n    /**\r\n     * {@inheritdoc Palette.colorContrast}\r\n     */\r\n    colorContrast(reference, contrastTarget, initialSearchIndex, direction) {\r\n        if (initialSearchIndex === undefined) {\r\n            initialSearchIndex = this.closestIndexOf(reference);\r\n        }\r\n        let source = this.swatches;\r\n        const endSearchIndex = this.lastIndex;\r\n        let startSearchIndex = initialSearchIndex;\r\n        if (direction === undefined) {\r\n            direction = directionByIsDark(reference);\r\n        }\r\n        const condition = (value) => contrast(reference, value) >= contrastTarget;\r\n        if (direction === -1) {\r\n            source = this.reversedSwatches;\r\n            startSearchIndex = endSearchIndex - startSearchIndex;\r\n        }\r\n        return binarySearch(source, condition, startSearchIndex, endSearchIndex);\r\n    }\r\n    /**\r\n     * {@inheritdoc Palette.get}\r\n     */\r\n    get(index) {\r\n        return this.swatches[index] || this.swatches[clamp(index, 0, this.lastIndex)];\r\n    }\r\n    /**\r\n     * {@inheritdoc Palette.closestIndexOf}\r\n     */\r\n    closestIndexOf(reference) {\r\n        if (this.closestIndexCache.has(reference.relativeLuminance)) {\r\n            return this.closestIndexCache.get(reference.relativeLuminance);\r\n        }\r\n        let index = this.swatches.indexOf(reference);\r\n        if (index !== -1) {\r\n            this.closestIndexCache.set(reference.relativeLuminance, index);\r\n            return index;\r\n        }\r\n        const closest = this.swatches.reduce((previous, next) => Math.abs(next.relativeLuminance - reference.relativeLuminance) <\r\n            Math.abs(previous.relativeLuminance - reference.relativeLuminance)\r\n            ? next\r\n            : previous);\r\n        index = this.swatches.indexOf(closest);\r\n        this.closestIndexCache.set(reference.relativeLuminance, index);\r\n        return index;\r\n    }\r\n    /**\r\n     * Bump the saturation if it falls below the reference color saturation.\r\n     * @param reference Color with target saturation\r\n     * @param color Color to check and bump if below target saturation\r\n     * @returns Original or adjusted color\r\n     */\r\n    static saturationBump(reference, color) {\r\n        const hslReference = rgbToHSL(reference);\r\n        const saturationTarget = hslReference.s;\r\n        const hslColor = rgbToHSL(color);\r\n        if (hslColor.s < saturationTarget) {\r\n            const hslNew = new ColorHSL(hslColor.h, saturationTarget, hslColor.l);\r\n            return hslToRGB(hslNew);\r\n        }\r\n        return color;\r\n    }\r\n    /**\r\n     * Scales input from 0 to 100 to 0 to 0.5.\r\n     * @param l Input number, 0 to 100\r\n     * @returns Output number, 0 to 0.5\r\n     */\r\n    static ramp(l) {\r\n        const inputval = l / 100;\r\n        if (inputval > 0.5)\r\n            return (inputval - 0.5) / 0.5; //from 0.500001in = 0.00000001out to 1.0in = 1.0out\r\n        return 2 * inputval; //from 0in = 0out to 0.5in = 1.0out\r\n    }\r\n    /**\r\n     * Create a palette following the desired curve and many steps to build a smaller palette from.\r\n     * @param source The source swatch to create a palette from\r\n     * @returns The palette\r\n     */\r\n    static createHighResolutionPalette(source) {\r\n        const swatches = [];\r\n        const labSource = rgbToLAB(ColorRGBA64.fromObject(source).roundToPrecision(4));\r\n        const lab0 = labToRGB(new ColorLAB(0, labSource.a, labSource.b)).clamp().roundToPrecision(4);\r\n        const lab50 = labToRGB(new ColorLAB(50, labSource.a, labSource.b)).clamp().roundToPrecision(4);\r\n        const lab100 = labToRGB(new ColorLAB(100, labSource.a, labSource.b)).clamp().roundToPrecision(4);\r\n        const rgbMin = new ColorRGBA64(0, 0, 0);\r\n        const rgbMax = new ColorRGBA64(1, 1, 1);\r\n        const lAbove = lab100.equalValue(rgbMax) ? 0 : 14;\r\n        const lBelow = lab0.equalValue(rgbMin) ? 0 : 14;\r\n        // 257 levels max, depending on whether lab0 or lab100 are black or white respectively.\r\n        for (let l = 100 + lAbove; l >= 0 - lBelow; l -= 0.5) {\r\n            let rgb;\r\n            if (l < 0) {\r\n                // For L less than 0, scale from black to L=0\r\n                const percentFromRgbMinToLab0 = l / lBelow + 1;\r\n                rgb = interpolateRGB(percentFromRgbMinToLab0, rgbMin, lab0);\r\n            }\r\n            else if (l <= 50) {\r\n                // For L less than 50, we scale from L=0 to the base color\r\n                rgb = interpolateRGB(PaletteRGBImpl.ramp(l), lab0, lab50);\r\n            }\r\n            else if (l <= 100) {\r\n                // For L less than 100, scale from the base color to L=100\r\n                rgb = interpolateRGB(PaletteRGBImpl.ramp(l), lab50, lab100);\r\n            }\r\n            else {\r\n                // For L greater than 100, scale from L=100 to white\r\n                const percentFromLab100ToRgbMax = (l - 100.0) / lAbove;\r\n                rgb = interpolateRGB(percentFromLab100ToRgbMax, lab100, rgbMax);\r\n            }\r\n            rgb = PaletteRGBImpl.saturationBump(lab50, rgb).roundToPrecision(4);\r\n            swatches.push(SwatchRGB.from(rgb));\r\n        }\r\n        return new PaletteRGBImpl(source, swatches);\r\n    }\r\n    /**\r\n     * Adjust one end of the contrast-based palette so it doesn't abruptly fall to black (or white).\r\n     * @param swatchContrast Function to get the target contrast for the next swatch\r\n     * @param referencePalette The high resolution palette\r\n     * @param targetPalette The contrast-based palette to adjust\r\n     * @param direction The end to adjust\r\n     */\r\n    static adjustEnd(swatchContrast, referencePalette, targetPalette, direction) {\r\n        // Careful with the use of referencePalette as only the refSwatches is reversed.\r\n        const refSwatches = direction === -1 ? referencePalette.swatches : referencePalette.reversedSwatches;\r\n        const refIndex = (swatch) => {\r\n            const index = referencePalette.closestIndexOf(swatch);\r\n            return direction === 1 ? referencePalette.lastIndex - index : index;\r\n        };\r\n        // Only operates on the 'end' end of the array, so flip if we're adjusting the 'beginning'\r\n        if (direction === 1) {\r\n            targetPalette.reverse();\r\n        }\r\n        const targetContrast = swatchContrast(targetPalette[targetPalette.length - 2]);\r\n        const actualContrast = roundToPrecisionSmall(contrast(targetPalette[targetPalette.length - 1], targetPalette[targetPalette.length - 2]), 2);\r\n        if (actualContrast < targetContrast) {\r\n            // Remove last swatch if not sufficient contrast\r\n            targetPalette.pop();\r\n            // Distribute to the last swatch\r\n            const safeSecondSwatch = referencePalette.colorContrast(refSwatches[referencePalette.lastIndex], targetContrast, undefined, direction);\r\n            const safeSecondRefIndex = refIndex(safeSecondSwatch);\r\n            const targetSwatchCurrentRefIndex = refIndex(targetPalette[targetPalette.length - 2]);\r\n            const swatchesToSpace = safeSecondRefIndex - targetSwatchCurrentRefIndex;\r\n            let space = 1;\r\n            for (let i = targetPalette.length - swatchesToSpace - 1; i < targetPalette.length; i++) {\r\n                const currentRefIndex = refIndex(targetPalette[i]);\r\n                const nextRefIndex = i === targetPalette.length - 1 ? referencePalette.lastIndex : currentRefIndex + space;\r\n                targetPalette[i] = refSwatches[nextRefIndex];\r\n                space++;\r\n            }\r\n        }\r\n        if (direction === 1) {\r\n            targetPalette.reverse();\r\n        }\r\n    }\r\n    /**\r\n     * Generate a palette with consistent minimum contrast between swatches.\r\n     * @param source The source color\r\n     * @param options Palette generation options\r\n     * @returns A palette meeting the requested contrast between swatches.\r\n     */\r\n    static createColorPaletteByContrast(source, options) {\r\n        const referencePalette = PaletteRGBImpl.createHighResolutionPalette(source);\r\n        // Ramp function to increase contrast as the swatches get darker\r\n        const nextContrast = (swatch) => {\r\n            const c = options.stepContrast + options.stepContrast * (1 - swatch.relativeLuminance) * options.stepContrastRamp;\r\n            return roundToPrecisionSmall(c, 2);\r\n        };\r\n        const swatches = [];\r\n        // Start with the source color or the light end color\r\n        let ref = options.preserveSource ? source : referencePalette.swatches[0];\r\n        swatches.push(ref);\r\n        // Add swatches with contrast toward dark\r\n        do {\r\n            const targetContrast = nextContrast(ref);\r\n            ref = referencePalette.colorContrast(ref, targetContrast, undefined, 1);\r\n            swatches.push(ref);\r\n        } while (ref.relativeLuminance > 0);\r\n        // Add swatches with contrast toward light\r\n        if (options.preserveSource) {\r\n            ref = source;\r\n            do {\r\n                // This is off from the dark direction because `ref` here is the darker swatch, probably subtle\r\n                const targetContrast = nextContrast(ref);\r\n                ref = referencePalette.colorContrast(ref, targetContrast, undefined, -1);\r\n                swatches.unshift(ref);\r\n            } while (ref.relativeLuminance < 1);\r\n        }\r\n        // Validate dark end\r\n        this.adjustEnd(nextContrast, referencePalette, swatches, -1);\r\n        // Validate light end\r\n        if (options.preserveSource) {\r\n            this.adjustEnd(nextContrast, referencePalette, swatches, 1);\r\n        }\r\n        return swatches;\r\n    }\r\n    /**\r\n     * Create a color palette from a provided swatch\r\n     * @param source - The source swatch to create a palette from\r\n     * @returns\r\n     */\r\n    static from(source, options) {\r\n        const opts = options === void 0 || null ? defaultPaletteRGBOptions : Object.assign(Object.assign({}, defaultPaletteRGBOptions), options);\r\n        return new PaletteRGBImpl(source, Object.freeze(PaletteRGBImpl.createColorPaletteByContrast(source, opts)));\r\n    }\r\n}\r\n","references":["/home/chassunc/projects/fluentui/node_modules/@microsoft/fast-colors/dist/index.d.ts","/home/chassunc/projects/fluentui/packages/web-components/src/color/swatch.ts","/home/chassunc/projects/fluentui/packages/web-components/src/color/utilities/binary-search.ts","/home/chassunc/projects/fluentui/packages/web-components/src/color/utilities/direction-by-is-dark.ts","/home/chassunc/projects/fluentui/packages/web-components/src/color/utilities/relative-luminance.ts"]}
