{"code":"import { calculateOverlayColor, ColorRGBA64, computeAlphaBlend, parseColorHexRGB } from '@microsoft/fast-colors';\r\nimport { SwatchRGB } from '../swatch';\r\nimport { directionByIsDark } from '../utilities/direction-by-is-dark';\r\nimport { GradientSwatchRGB } from './gradient-swatch';\r\nconst black = new ColorRGBA64(0, 0, 0);\r\nconst white = new ColorRGBA64(1, 1, 1);\r\n/**\r\n * @internal\r\n */\r\nexport function gradientShadowStroke(palette, reference, restDelta, hoverDelta, activeDelta, focusDelta, shadowDelta, direction, shadowPercentage = 10, blendWithReference = false) {\r\n    const referenceIndex = palette.closestIndexOf(reference);\r\n    if (direction === void 0) {\r\n        direction = directionByIsDark(reference);\r\n    }\r\n    function overlayHelper(color) {\r\n        if (blendWithReference) {\r\n            const refIndex = palette.closestIndexOf(reference);\r\n            const refSwatch = palette.get(refIndex);\r\n            const overlaySolid = color.relativeLuminance < reference.relativeLuminance ? black : white;\r\n            const overlayColor = calculateOverlayColor(parseColorHexRGB(color.toColorString()), parseColorHexRGB(refSwatch.toColorString()), overlaySolid).roundToPrecision(2);\r\n            const blend = computeAlphaBlend(parseColorHexRGB(reference.toColorString()), overlayColor);\r\n            return SwatchRGB.from(blend);\r\n        }\r\n        else {\r\n            return color;\r\n        }\r\n    }\r\n    const restIndex = referenceIndex + direction * restDelta;\r\n    const hoverIndex = restIndex + direction * (hoverDelta - restDelta);\r\n    const activeIndex = restIndex + direction * (activeDelta - restDelta);\r\n    const focusIndex = restIndex + direction * (focusDelta - restDelta);\r\n    const startPosition = direction === -1 ? 0 : 100 - shadowPercentage;\r\n    const endPosition = direction === -1 ? shadowPercentage : 100;\r\n    function gradientHelper(index, applyShadow) {\r\n        const color = palette.get(index);\r\n        if (applyShadow) {\r\n            // Shadow is actually \"highlight\" on top in dark mode.\r\n            const shadowColor = palette.get(index + direction * shadowDelta);\r\n            const startColor = direction === -1 ? shadowColor : color;\r\n            const endColor = direction === -1 ? color : shadowColor;\r\n            const g = `linear-gradient(${overlayHelper(startColor).toColorString()} ${startPosition}%, ${overlayHelper(endColor).toColorString()} ${endPosition}%)`;\r\n            return GradientSwatchRGB.fromObject(startColor, g);\r\n        }\r\n        else {\r\n            return overlayHelper(color);\r\n        }\r\n    }\r\n    return {\r\n        rest: gradientHelper(restIndex, true),\r\n        hover: gradientHelper(hoverIndex, true),\r\n        active: gradientHelper(activeIndex, false),\r\n        focus: gradientHelper(focusIndex, true),\r\n    };\r\n}\r\n","references":["/home/chassunc/projects/fluentui/node_modules/@microsoft/fast-colors/dist/index.d.ts","/home/chassunc/projects/fluentui/packages/web-components/src/color/palette.ts","/home/chassunc/projects/fluentui/packages/web-components/src/color/recipe.ts","/home/chassunc/projects/fluentui/packages/web-components/src/color/swatch.ts","/home/chassunc/projects/fluentui/packages/web-components/src/color/utilities/direction-by-is-dark.ts","/home/chassunc/projects/fluentui/packages/web-components/src/color/recipes/gradient-swatch.ts"]}
