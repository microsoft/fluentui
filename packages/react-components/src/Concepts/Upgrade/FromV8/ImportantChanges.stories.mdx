import { Meta } from '@storybook/addon-docs';

<Meta title="Concepts/Upgrading/from v8/Important changes" />

# Important changes you should know about

v9 introduces several paradigm shifts that were necessary to improve performance, ease development, and reduce bundle size.
This resulted in some breaking changes you will need to handle as you upgrade.

## Props vs. Children

In v8, several components had props that accepted arrays of data and used a map function to render the children.
To allow control over rendering individual items, render props callbacks were added.
Components that rendered large lists of items had lots of specific behavior (such as virtualization) hard coded within the component.

Components in v9 give you full control of rendering items by allowing you to pass child elements instead of data props.
This allows you to define and compose children however you like: declaring JSX elements or writing your own map function.
You don't have to define and pass separate renderprops functions to control the rendering of children.

This means that your existing code passing arrays of data will need to be updated to render child elements.

For example, `ContextualMenuButton` takes a menuProps containing menu data,
an optional menuAs to control the rendering of menu items,
and an optional onMenuClick.

```tsx
const menuProps: IContextualMenuProps = {
  items: [
    {
      key: 'emailMessage',
      text: 'Email message',
    },
    {
      key: 'calendarEvent',
      text: 'Calendar event',
    },
  ],
  directionalHintFixed: true,
};

function _getMenu(props: IContextualMenuProps): JSX.Element {
  return <ContextualMenu {...props} />;
}

function _onMenuClick(ev?: React.SyntheticEvent<any>) {
  console.log(ev);
}

<DefaultButton text="New item" menuProps={menuProps} menuAs={_getMenu} onMenuClick={_onMenuClick} />;
```

In v9, you get much more control over menus including what component triggers the display of the menu or submenu.
By specifying the children you directly control the rendering of each child and can wire up onClick handlers directly
rather than having to figure out which menuItem was clicked.

```tsx
<Menu>
  <MenuTrigger>
    <Button>New Item</Button>
  </MenuTrigger>
  <MenuPopover>
    <MenuList>
      <MenuItem onClick={onNewEmailMessage}>Email message</MenuItem>
      <MenuItem onClick={onNewCalendarEvent}>Calendar event</MenuItem>
    </MenuList>
  </MenuPopover>
</Menu>
```

You can continue to leverage existing data structures by writing a map function.

```tsx
<Menu>
  <MenuTrigger>
    <Button>
      New Item
    </Button>
  </MenuTrigger>
  <MenuPopover>
    <MenuList>
      {menuItems.map(item => <MenuItem onClick={item.onClick}>{item.name}</MenuItem>)
    </MenuList>
  </MenuPopover>
</Menu>
```

## Custom Styling

There are significant styling differences between v8 and v9.

In v8, styles props accepted javascript objects (IStyle).
These could created at build time or be parameterized to generate styles at runtime.
This had a negative impact on rendering performance.

In v9, styles are created with the `makeStyles` function and combined with the `mergeClasses` function.
Components apply styles through the className property.
The styles are created at build time, but never runtime.
This allows styles to be deduped, optimized, and bundled for significantly smaller bundles and improved CSS performance.

## Theming

**v8**

- The ThemeProvider component provides a contextual theme object.
- The theme is a collection of component styles, color palettes, fonts, and spacing.
- Components consume the theme through the theme object in state or the useTheme hook.
- Deprecated loadTheme and theme customizer support legacy themes.

**v9**

- The FluentProvider provides a contextual theme using css variables.
- The theme is a collection of design tokens. There are global tokens for colors and sizes. There are alias tokens for general purpose component parts (e.g. background, border);
- Components consume the theme through CSS variables. A tokens object provides access to the variables.

## Render Customization

**v8** - Rendering is customized through render props callback provided by individual components.

**v9** - Components provide slots that allow replacement of specific parts.
