import { Meta } from '@storybook/addon-docs';
import { Spinner } from '@fluentui/react-spinner';

<Meta title="Concepts/Developer/Icons" />

## Icons

The Fluent UI SVG icon set is released under the MIT License. There are three ways you can consume the fluent icon set in your application, with perks and drawbacks to each.

### Fluent Icons as React Elements

The `@fluentui/react-icons` package is an icon offering from the [fluentui-system-icons](https://github.com/microsoft/fluentui-system-icons/tree/master/packages/react-icons) design set. It contains SVG-based icons wrapped in React components. Because each icon is its own component, you only need to import and bundle the icons used in your application.

There are two different styles of each icon, `Filled` and `Regular`. These are by default sized to `1em`, and can be scaled up or down to suit your needs.

To use these icons, simply import them as `import { [IconName][Style] } from @fluentui/react-icons`. For example:

```tsx
import { AccessTimeFilled } from '@fluentui/react-icons';
```

If you know what size you want to use for your icons, and they don't need to be resized dynamically, it is recommended to use the sized icons. These are the same icons as in the general case, but in multiple different sizes, built to look pixel-perfect at each size.
You can import the sized icons in a similar way:

```tsx
import { AccessTime24Filled } from '@fluentui/react-icons';
```

Each icon also accepts `className` and `primaryFill` props for styling.

### Fluent Icons as Fonts

The fluent icons also can be consumed as a font. The API is the same as the react-element icons, and there are tools to allow you to more seamlessly integrate the font icons
into your application. You will also be able to only bundle the font icons you need in your application using the the package `@fluentui/react-icons-font-subsetting-webpack-plugin`

If `optimization.usedExports` is enabled (as it is by default), this plugin will subset the font files to only include the glyphs actually used by your build.
Here is how you set up your webpack configuration to use font files in your application:

```js
// webpack.config.js
const {
  default: FluentUIReactIconsFontSubsettingPlugin,
} = require('@fluentui/react-icons-font-subsetting-webpack-plugin');

module.exports = {
  module: {
    rules: [
      // Treat the font files as webpack assets
      {
        test: /\.(ttf|woff2?)$/,
        type: 'asset',
      },
    ],
  },
  resolve: {
    // Include 'fluentIcontFont' to use the font implementation of the Fluent icons
    conditionNames: ['fluentIcontFont', 'import'],
  },
  plugins: [
    // Include this plugin
    new FluentUIReactIconsFontSubsettingPlugin(),
  ],
};
```

### Fluent Icons as SVG Sprites

Another way that you can consume the fluent icons is by using them as svg-sprites. The fluent svg-sprites are located in the package `@fluentui/svg-sprites`.
This package provides the Fluent UI System Icons as SVG sprites, which allow user agents to request and cache icons at runtime.

For security reasons, most user agents require the sprites to be served from the same hostname, protocol and port. During development, requests can be proxied to a specific release on e.g. jsdelivr which you have vetted for integrity, a bucket in the cloud, or served from the serviceâ€™s file system.

For Storybook, `middleware.js` allows the configuration of `http-proxy-middleware` like so:

```js
const { createProxyMiddleware } = require('http-proxy-middleware');

const expressMiddleWare = router => {
  router.use(
    '/sprites',
    createProxyMiddleware({
      target: 'http://cdn.jsdelivr.net/npm/@fluentui/svg-sprites',
      changeOrigin: true,
      followRedirects: true,
    }),
  );
};

module.exports = expressMiddleWare;
```

Sprites can then be consumed by the client like so:

```tsx
export const Icon = (props: IconProps) => {
  const { icon, variant = 'regular', size = 20 } = props;
  const assetId = `${icon}_${size}_${variant}`;
  return (
    <svg>
      <use href={`/sprites/${assetId}.sprite.svg#${assetId}`} />
    </svg>
  );
};
```

## Pros and Cons of Each Icon Approach

#### Icons as React Elements

Pros

- The visual fidelity of the icons imported here are the highest
- These icons are the easiest to use right out of the gate. They require no setup except for importing the icons that you need from `@fluentui/react-icons`
- Has treeshaking enabled when using esm node modules

Cons

- If you are not using esm modules in your application, then treeshaking will not work properly, and icons that you don't use in the application
  could get bundled in along with the icons you do use. This means your perf and bundle size would take a hit importing the icons.

#### Icons as Font

Pros

- Render perf is better in applications, as the font files are downloaded on application load and get rendered as an image
- The font subsetting webpack plugin detects the icons that you use in your application and downloads only those to your application

Cons

- There is a slight dropoff in the visual fidelity of the font icons, but this is not noticeable at most sizes
- There is more setup required to use the font icons than using the svg based icons i.e, setting up the webpack plugin

#### Icons as Svg Sprites

Pros

- You can request and cache the icons at runtime. This drastically reduces the number of HTTP requests, improving render perf right out of the gate
- You can use a simple `svg` html tag with the `use` tag to quickly and efficiently insert the icons you want to use in your application

Cons

- Using symbol sprites won't work for multicolored icons
- Any new icons used has to be cached again

### Available Icons

<React.Suspense fallback={<Spinner label="Loading..." />}>
  {React.createElement(React.lazy(() => import('./ReactIconGrid')))}
</React.Suspense>
